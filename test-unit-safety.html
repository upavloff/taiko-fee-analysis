<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Safety System Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f7fa;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .test-section {
            background: white;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border-left: 5px solid #667eea;
        }

        .test-section h2 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        .status {
            padding: 10px 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }

        .status.pass {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status.fail {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status.warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }

        .code {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            overflow-x: auto;
            border-left: 4px solid #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            margin-top: 30px;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .diagnostic-section {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e74c3c;
        }

        .diagnostic-section h3 {
            color: #e74c3c;
            margin-top: 0;
        }

        input[type="number"], select {
            width: 100px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üõ°Ô∏è Unit Safety System Test Suite</h1>
        <p>Comprehensive testing for ETH/Wei/Gwei unit conversion safety</p>
    </div>

    <div class="test-section">
        <h2>üöÄ Quick Test Runner</h2>
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="runEmergencyCheck()">Emergency Check</button>
        <button onclick="runDiagnosticTests()">Unit Diagnostics</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="diagnostic-section">
        <h3>üîç Manual Unit Diagnosis</h3>
        <p>Test specific values for unit conversion issues:</p>
        <div>
            Value: <input type="number" id="diagValue" placeholder="0.0001" step="any">
            Unit: <select id="diagUnit">
                <option value="gwei">Gwei</option>
                <option value="wei">Wei</option>
                <option value="eth">ETH</option>
            </select>
            <button onclick="diagnoseValue()">Diagnose</button>
        </div>
        <div id="diagnosisResult"></div>
    </div>

    <div class="test-grid">
        <div class="test-section">
            <h2>üìê Unit Conversion Tests</h2>
            <div id="conversionResults"></div>
        </div>

        <div class="test-section">
            <h2>üéØ Range Validation Tests</h2>
            <div id="validationResults"></div>
        </div>

        <div class="test-section">
            <h2>üßÆ Fee Calculation Tests</h2>
            <div id="calculationResults"></div>
        </div>

        <div class="test-section">
            <h2>‚ö†Ô∏è Error Detection Tests</h2>
            <div id="errorDetectionResults"></div>
        </div>
    </div>

    <div class="summary" id="testSummary" style="display: none;">
        <div id="summaryContent"></div>
    </div>

    <script type="module">
        // Import unit validation (handle both cases where it might be available)
        let unitValidation = null;
        let UNIT_SAFETY_AVAILABLE = false;

        try {
            // Try to import from local module
            const module = await import('./src/core/unit_validation.js');
            unitValidation = module.default || module;
            UNIT_SAFETY_AVAILABLE = true;
            console.log('‚úÖ Unit validation module loaded');
        } catch (error) {
            console.warn('‚ö†Ô∏è Unit validation module not available:', error);
            // Create mock functions for testing
            unitValidation = createMockUnitValidation();
        }

        function createMockUnitValidation() {
            return {
                validateFeeRange: (fee, context) => {
                    if (fee < 0.001 || fee > 10000) {
                        throw new Error(`Fee ${fee} gwei outside reasonable range in ${context}`);
                    }
                },
                validateBasefeeRange: (basefee, context) => {
                    if (basefee < 0.001 || basefee > 2000) {
                        console.warn(`Basefee ${basefee} gwei outside typical range in ${context}`);
                    }
                },
                assertReasonableFee: (fee, context) => {
                    if (fee > 0 && fee < 0.0001) {
                        throw new Error(`Fee ${fee} gwei suspiciously small in ${context}`);
                    }
                },
                gweiToWei: (gwei) => gwei * 1e9,
                weiToGwei: (wei) => wei / 1e9,
                ethToWei: (eth) => eth * 1e18,
                weiToEth: (wei) => wei / 1e18,
                diagnoseUnitMismatch: (value, unit) => {
                    let diagnosis = `Value: ${value} alleged to be ${unit}\n`;
                    if (unit === 'gwei' && value < 0.001) {
                        diagnosis += '‚ö†Ô∏è LIKELY ISSUE: Too small for gwei, might be ETH';
                    } else if (unit === 'wei' && value < 1e15) {
                        diagnosis += '‚ö†Ô∏è POSSIBLE ISSUE: Very small for wei';
                    } else {
                        diagnosis += '‚úÖ Value seems reasonable for alleged unit';
                    }
                    return diagnosis;
                },
                UnitValidationError: class extends Error { constructor(msg) { super(msg); this.name = 'UnitValidationError'; } }
            };
        }

        // Make functions available globally
        window.unitValidation = unitValidation;
        window.UNIT_SAFETY_AVAILABLE = UNIT_SAFETY_AVAILABLE;

        console.log(`Unit safety available: ${UNIT_SAFETY_AVAILABLE}`);
    </script>

    <script>
        // Test state
        let testResults = {
            passed: 0,
            failed: 0,
            warnings: 0
        };

        // Utility functions
        function addResult(elementId, testName, status, message, details = '') {
            const element = document.getElementById(elementId);
            const resultDiv = document.createElement('div');
            resultDiv.className = 'test-result';

            let statusClass = 'pass';
            let statusIcon = '‚úÖ';

            if (status === 'fail') {
                statusClass = 'fail';
                statusIcon = '‚ùå';
                testResults.failed++;
            } else if (status === 'warning') {
                statusClass = 'warning';
                statusIcon = '‚ö†Ô∏è';
                testResults.warnings++;
            } else {
                testResults.passed++;
            }

            resultDiv.innerHTML = `
                <div class="status ${statusClass}">
                    ${statusIcon} ${testName}
                </div>
                <div>${message}</div>
                ${details ? `<div class="code">${details}</div>` : ''}
            `;

            element.appendChild(resultDiv);
        }

        function clearResults() {
            const resultDivs = ['conversionResults', 'validationResults', 'calculationResults', 'errorDetectionResults'];
            resultDivs.forEach(id => {
                document.getElementById(id).innerHTML = '';
            });

            document.getElementById('testSummary').style.display = 'none';
            document.getElementById('diagnosisResult').innerHTML = '';

            testResults = { passed: 0, failed: 0, warnings: 0 };
        }

        // Conversion tests
        function runConversionTests() {
            console.log('Running conversion tests...');

            // Test 1: Basic gwei to wei conversion
            try {
                const gweiValue = 50.0;
                const weiValue = unitValidation.gweiToWei(gweiValue);
                const expectedWei = gweiValue * 1e9;

                if (Math.abs(weiValue - expectedWei) < 1) {
                    addResult('conversionResults', 'Gwei to Wei Conversion', 'pass',
                        `${gweiValue} gwei = ${weiValue.toLocaleString()} wei`);
                } else {
                    addResult('conversionResults', 'Gwei to Wei Conversion', 'fail',
                        `Expected ${expectedWei}, got ${weiValue}`);
                }
            } catch (error) {
                addResult('conversionResults', 'Gwei to Wei Conversion', 'fail', error.message);
            }

            // Test 2: Wei to gwei roundtrip
            try {
                const originalGwei = 123.456789;
                const weiValue = unitValidation.gweiToWei(originalGwei);
                const backToGwei = unitValidation.weiToGwei(weiValue);

                if (Math.abs(backToGwei - originalGwei) < 1e-6) {
                    addResult('conversionResults', 'Wei‚ÜîGwei Roundtrip', 'pass',
                        `${originalGwei} gwei ‚Üí wei ‚Üí ${backToGwei.toFixed(6)} gwei`);
                } else {
                    addResult('conversionResults', 'Wei‚ÜîGwei Roundtrip', 'fail',
                        `Precision lost: ${originalGwei} ‚Üí ${backToGwei}`);
                }
            } catch (error) {
                addResult('conversionResults', 'Wei‚ÜîGwei Roundtrip', 'fail', error.message);
            }

            // Test 3: ETH to wei conversion
            try {
                const ethValue = 0.001;
                const weiValue = unitValidation.ethToWei(ethValue);
                const expectedWei = ethValue * 1e18;

                if (Math.abs(weiValue - expectedWei) < 1) {
                    addResult('conversionResults', 'ETH to Wei Conversion', 'pass',
                        `${ethValue} ETH = ${weiValue.toLocaleString()} wei`);
                } else {
                    addResult('conversionResults', 'ETH to Wei Conversion', 'fail',
                        `Expected ${expectedWei}, got ${weiValue}`);
                }
            } catch (error) {
                addResult('conversionResults', 'ETH to Wei Conversion', 'fail', error.message);
            }

            // Test 4: Known exact values
            const knownConversions = [
                { gwei: 1, expectedWei: 1000000000 },
                { gwei: 50.123, expectedWei: 50123000000 }
            ];

            knownConversions.forEach(test => {
                try {
                    const result = unitValidation.gweiToWei(test.gwei);
                    if (result === test.expectedWei) {
                        addResult('conversionResults', `Known Value: ${test.gwei} gwei`, 'pass',
                            `Correctly converts to ${test.expectedWei} wei`);
                    } else {
                        addResult('conversionResults', `Known Value: ${test.gwei} gwei`, 'fail',
                            `Expected ${test.expectedWei}, got ${result}`);
                    }
                } catch (error) {
                    addResult('conversionResults', `Known Value: ${test.gwei} gwei`, 'fail', error.message);
                }
            });
        }

        // Validation tests
        function runValidationTests() {
            console.log('Running validation tests...');

            // Test 1: Valid fee ranges
            const validFees = [1.0, 10.0, 100.0, 1000.0];
            validFees.forEach(fee => {
                try {
                    unitValidation.validateFeeRange(fee, 'test');
                    addResult('validationResults', `Valid Fee: ${fee} gwei`, 'pass',
                        'Fee passes range validation');
                } catch (error) {
                    addResult('validationResults', `Valid Fee: ${fee} gwei`, 'fail', error.message);
                }
            });

            // Test 2: Invalid fee ranges
            const invalidFees = [0.0001, 50000];
            invalidFees.forEach(fee => {
                try {
                    unitValidation.validateFeeRange(fee, 'test');
                    addResult('validationResults', `Invalid Fee: ${fee} gwei`, 'fail',
                        'Should have rejected this fee');
                } catch (error) {
                    addResult('validationResults', `Invalid Fee: ${fee} gwei`, 'pass',
                        `Correctly rejected: ${error.message}`);
                }
            });

            // Test 3: Basefee range validation (warnings)
            const basefees = [
                { value: 0.0001, expectWarning: true },
                { value: 50.0, expectWarning: false },
                { value: 5000.0, expectWarning: true }
            ];

            basefees.forEach(test => {
                try {
                    const originalWarn = console.warn;
                    let warningCaught = false;
                    console.warn = () => { warningCaught = true; };

                    unitValidation.validateBasefeeRange(test.value, 'test');
                    console.warn = originalWarn;

                    if (test.expectWarning === warningCaught) {
                        addResult('validationResults', `Basefee: ${test.value} gwei`, 'pass',
                            `Warning behavior correct (expected: ${test.expectWarning}, got: ${warningCaught})`);
                    } else {
                        addResult('validationResults', `Basefee: ${test.value} gwei`, 'warning',
                            `Warning behavior mismatch (expected: ${test.expectWarning}, got: ${warningCaught})`);
                    }
                } catch (error) {
                    addResult('validationResults', `Basefee: ${test.value} gwei`, 'fail', error.message);
                }
            });

            // Test 4: Reasonable fee assertions
            try {
                unitValidation.assertReasonableFee(0.00001, 'test');
                addResult('validationResults', 'Unreasonable Fee Detection', 'fail',
                    'Should have caught suspiciously small fee');
            } catch (error) {
                addResult('validationResults', 'Unreasonable Fee Detection', 'pass',
                    `Correctly caught: ${error.message}`);
            }
        }

        // Fee calculation tests
        function runCalculationTests() {
            console.log('Running calculation tests...');

            // Test 1: L1 cost calculation
            const l1Scenarios = [
                { basefeeGwei: 50, gasPerTx: 20000, expectedCostETH: 0.001 },
                { basefeeGwei: 100, gasPerTx: 20000, expectedCostETH: 0.002 },
                { basefeeGwei: 10, gasPerTx: 20000, expectedCostETH: 0.0002 }
            ];

            l1Scenarios.forEach(scenario => {
                try {
                    const basefeeWei = scenario.basefeeGwei * 1e9;
                    const l1CostETH = (basefeeWei * scenario.gasPerTx) / 1e18;

                    if (Math.abs(l1CostETH - scenario.expectedCostETH) < 1e-8) {
                        addResult('calculationResults', `L1 Cost: ${scenario.basefeeGwei} gwei`, 'pass',
                            `${scenario.basefeeGwei} gwei √ó ${scenario.gasPerTx} gas = ${l1CostETH.toFixed(6)} ETH`);
                    } else {
                        addResult('calculationResults', `L1 Cost: ${scenario.basefeeGwei} gwei`, 'fail',
                            `Expected ${scenario.expectedCostETH}, got ${l1CostETH}`);
                    }
                } catch (error) {
                    addResult('calculationResults', `L1 Cost: ${scenario.basefeeGwei} gwei`, 'fail', error.message);
                }
            });

            // Test 2: Fee formula calculation
            const feeScenarios = [
                { mu: 0.0, nu: 0.27, H: 492, l1CostETH: 0.001, deficitETH: 0, minFeeExpected: true },
                { mu: 0.0, nu: 0.27, H: 492, l1CostETH: 0.001, deficitETH: 492, expectedFeeGwei: 0.27 },
                { mu: 0.5, nu: 0.27, H: 144, l1CostETH: 0.002, deficitETH: 144, expectedFeeGwei: 1.27 }
            ];

            feeScenarios.forEach((scenario, index) => {
                try {
                    const l1Component = scenario.mu * scenario.l1CostETH;
                    const deficitComponent = scenario.nu * scenario.deficitETH / scenario.H;
                    const rawFee = l1Component + deficitComponent;
                    const finalFee = Math.max(rawFee, 1e-8); // 1e-8 ETH min fee
                    const finalFeeGwei = finalFee * 1e9;

                    let testPassed = false;
                    let message = '';

                    if (scenario.minFeeExpected) {
                        testPassed = Math.abs(finalFeeGwei - 0.01) < 1e-6; // 1e-8 ETH = 0.01 gwei
                        message = `Min fee applied: ${finalFeeGwei.toFixed(6)} gwei`;
                    } else if (scenario.expectedFeeGwei) {
                        testPassed = Math.abs(finalFeeGwei - scenario.expectedFeeGwei) < 0.01;
                        message = `Fee: ${finalFeeGwei.toFixed(6)} gwei (expected: ${scenario.expectedFeeGwei} gwei)`;
                    }

                    addResult('calculationResults', `Fee Formula Test ${index + 1}`,
                        testPassed ? 'pass' : 'fail', message,
                        `Œº=${scenario.mu}, ŒΩ=${scenario.nu}, H=${scenario.H}, L1=${scenario.l1CostETH}ETH, deficit=${scenario.deficitETH}ETH`);

                } catch (error) {
                    addResult('calculationResults', `Fee Formula Test ${index + 1}`, 'fail', error.message);
                }
            });
        }

        // Error detection tests
        function runErrorDetectionTests() {
            console.log('Running error detection tests...');

            // Test 1: Unit mismatch scenarios
            const mismatchScenarios = [
                { value: 0.0001, allegedUnit: 'gwei', expectedIssue: true, description: 'ETH passed as gwei' },
                { value: 50000000000, allegedUnit: 'gwei', expectedIssue: true, description: 'Wei passed as gwei' },
                { value: 50.0, allegedUnit: 'gwei', expectedIssue: false, description: 'Correct gwei value' },
                { value: 1e-12, allegedUnit: 'eth', expectedIssue: true, description: 'Wei passed as ETH' }
            ];

            mismatchScenarios.forEach(scenario => {
                try {
                    const diagnosis = unitValidation.diagnoseUnitMismatch(scenario.value, scenario.allegedUnit);
                    const hasIssue = diagnosis.includes('LIKELY ISSUE') || diagnosis.includes('POSSIBLE ISSUE');

                    if (hasIssue === scenario.expectedIssue) {
                        addResult('errorDetectionResults', scenario.description, 'pass',
                            `Correctly detected mismatch: ${hasIssue}`);
                    } else {
                        addResult('errorDetectionResults', scenario.description, 'fail',
                            `Expected issue: ${scenario.expectedIssue}, detected: ${hasIssue}`);
                    }
                } catch (error) {
                    addResult('errorDetectionResults', scenario.description, 'fail', error.message);
                }
            });

            // Test 2: Overflow protection tests
            try {
                unitValidation.gweiToWei(1e20); // Should cause overflow
                addResult('errorDetectionResults', 'Overflow Protection', 'fail',
                    'Should have caught overflow');
            } catch (error) {
                if (error.name === 'UnitOverflowError' || error.message.includes('overflow')) {
                    addResult('errorDetectionResults', 'Overflow Protection', 'pass',
                        'Correctly caught overflow');
                } else {
                    addResult('errorDetectionResults', 'Overflow Protection', 'warning',
                        `Caught error but not overflow: ${error.message}`);
                }
            }

            // Test 3: Negative value protection
            try {
                unitValidation.gweiToWei(-10);
                addResult('errorDetectionResults', 'Negative Value Protection', 'fail',
                    'Should have rejected negative value');
            } catch (error) {
                addResult('errorDetectionResults', 'Negative Value Protection', 'pass',
                    'Correctly rejected negative value');
            }
        }

        // Emergency check
        function runEmergencyCheck() {
            console.log('Running emergency check...');
            clearResults();

            // Quick critical tests
            try {
                // Test 1: Basic functionality
                const testGwei = 50.0;
                const testWei = unitValidation.gweiToWei(testGwei);
                const backToGwei = unitValidation.weiToGwei(testWei);

                if (Math.abs(backToGwei - testGwei) < 1e-6) {
                    addResult('conversionResults', 'üö® Emergency: Basic Conversion', 'pass',
                        'Unit conversions working');
                } else {
                    addResult('conversionResults', 'üö® Emergency: Basic Conversion', 'fail',
                        'Critical conversion failure');
                }

                // Test 2: Fee validation
                unitValidation.validateFeeRange(10.0, 'emergency');
                addResult('validationResults', 'üö® Emergency: Fee Validation', 'pass',
                    'Fee validation working');

                // Test 3: Error detection
                try {
                    unitValidation.assertReasonableFee(0.00001, 'emergency');
                    addResult('errorDetectionResults', 'üö® Emergency: Error Detection', 'fail',
                        'Should catch unreasonable fees');
                } catch (e) {
                    addResult('errorDetectionResults', 'üö® Emergency: Error Detection', 'pass',
                        'Error detection working');
                }

                updateTestSummary('Emergency check completed');

            } catch (error) {
                addResult('errorDetectionResults', 'üö® Emergency: System Failure', 'fail',
                    `Critical system failure: ${error.message}`);
                updateTestSummary('Emergency check failed - critical issues detected');
            }
        }

        // Run all tests
        function runAllTests() {
            console.log('Running all unit safety tests...');
            clearResults();

            try {
                runConversionTests();
                runValidationTests();
                runCalculationTests();
                runErrorDetectionTests();

                updateTestSummary('Full test suite completed');
            } catch (error) {
                console.error('Test suite error:', error);
                updateTestSummary('Test suite failed with errors');
            }
        }

        // Diagnostic tests
        function runDiagnosticTests() {
            console.log('Running diagnostic tests...');
            clearResults();

            const diagnosticScenarios = [
                { value: 0.000001, unit: 'gwei', name: 'Extremely small fee' },
                { value: 50.0, unit: 'gwei', name: 'Normal fee' },
                { value: 50000000000, unit: 'gwei', name: 'Suspected wei as gwei' },
                { value: 0.000001, unit: 'eth', name: 'Suspected wei as ETH' },
                { value: 100, unit: 'wei', name: 'Very small wei value' }
            ];

            diagnosticScenarios.forEach(scenario => {
                try {
                    const diagnosis = unitValidation.diagnoseUnitMismatch(scenario.value, scenario.unit);
                    const hasIssue = diagnosis.includes('ISSUE');

                    addResult('conversionResults', scenario.name, hasIssue ? 'warning' : 'pass',
                        `${scenario.value} ${scenario.unit}`, diagnosis);
                } catch (error) {
                    addResult('conversionResults', scenario.name, 'fail', error.message);
                }
            });

            updateTestSummary('Diagnostic tests completed');
        }

        // Manual diagnosis
        function diagnoseValue() {
            const value = parseFloat(document.getElementById('diagValue').value);
            const unit = document.getElementById('diagUnit').value;
            const resultDiv = document.getElementById('diagnosisResult');

            if (isNaN(value)) {
                resultDiv.innerHTML = '<div class="status fail">‚ùå Please enter a valid number</div>';
                return;
            }

            try {
                const diagnosis = unitValidation.diagnoseUnitMismatch(value, unit);
                const hasIssue = diagnosis.includes('ISSUE');

                resultDiv.innerHTML = `
                    <div class="status ${hasIssue ? 'warning' : 'pass'}">
                        ${hasIssue ? '‚ö†Ô∏è' : '‚úÖ'} Diagnosis for ${value} ${unit}
                    </div>
                    <div class="code">${diagnosis.replace(/\n/g, '<br>')}</div>
                `;
            } catch (error) {
                resultDiv.innerHTML = `<div class="status fail">‚ùå Diagnosis failed: ${error.message}</div>`;
            }
        }

        // Update test summary
        function updateTestSummary(message) {
            const summaryDiv = document.getElementById('testSummary');
            const contentDiv = document.getElementById('summaryContent');

            const total = testResults.passed + testResults.failed + testResults.warnings;

            let status = 'pass';
            let icon = '‚úÖ';

            if (testResults.failed > 0) {
                status = 'fail';
                icon = '‚ùå';
            } else if (testResults.warnings > 0) {
                status = 'warning';
                icon = '‚ö†Ô∏è';
            }

            contentDiv.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">${icon} ${message}</div>
                <div>
                    Tests: ${total} |
                    Passed: ${testResults.passed} |
                    Failed: ${testResults.failed} |
                    Warnings: ${testResults.warnings}
                </div>
                <div style="margin-top: 10px; font-size: 14px;">
                    Unit Safety System: ${UNIT_SAFETY_AVAILABLE ? 'Available' : 'Mock Mode'}
                </div>
            `;

            summaryDiv.style.display = 'block';
            summaryDiv.className = `summary ${status}`;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Unit Safety Test Suite initialized');

            // Show availability status
            const availabilityDiv = document.createElement('div');
            availabilityDiv.className = `status ${UNIT_SAFETY_AVAILABLE ? 'pass' : 'warning'}`;
            availabilityDiv.innerHTML = `
                ${UNIT_SAFETY_AVAILABLE ? '‚úÖ' : '‚ö†Ô∏è'}
                Unit Safety System: ${UNIT_SAFETY_AVAILABLE ? 'Available' : 'Mock Mode'}
            `;

            document.querySelector('.test-section').appendChild(availabilityDiv);
        });
    </script>
</body>
</html>