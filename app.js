// Built from web_src/ - DO NOT EDIT DIRECTLY
// This file is generated by web_src/build.js

// === historical-data-loader.js ===
/**
 * Historical Data Loader for Taiko Fee Analysis
 * Loads and manages the 4 historical datasets used in the research
 */

class HistoricalDataLoader {
    constructor() {
        this.datasets = {};
        this.datasetPaths = {
            'july_2022_spike': 'data_cache/real_july_2022_spike_data.csv',
            'luna_crash': 'data_cache/luna_crash_true_peak_contiguous.csv',
            'pepe_crisis': 'data_cache/may_2023_pepe_crisis_data.csv',
            'normal_operation': 'data_cache/recent_low_fees_3hours.csv'
        };
        this.loaded = false;
    }

    /**
     * Load all historical datasets
     * @returns {Promise<boolean>} Success status
     */
    async loadAllDatasets() {
        try {
            console.log('Loading historical datasets...');
            this.showDataLoadingStatus('Loading historical datasets...', 'loading');

            for (const [name, path] of Object.entries(this.datasetPaths)) {
                console.log(`Loading ${name} from ${path}...`);
                this.datasets[name] = await this.loadCsvData(path);
                console.log(`Loaded ${this.datasets[name].length} data points for ${name}`);
            }

            this.loaded = true;
            console.log('All historical datasets loaded successfully');
            this.showDataLoadingStatus('‚úÖ Historical data loaded successfully', 'success');
            return true;
        } catch (error) {
            console.error('Failed to load historical datasets:', error);
            this.showDataLoadingStatus('‚ùå Historical data failed to load. Please serve over HTTP (not file://). Charts will use simulated data.', 'error');
            return false;
        }
    }

    /**
     * Load CSV data from file path
     * @param {string} path File path
     * @returns {Promise<Array>} Parsed data
     */
    async loadCsvData(path) {
        const response = await fetch(path);
        if (!response.ok) {
            throw new Error(`Failed to load ${path}: ${response.statusText}`);
        }

        const csvText = await response.text();
        return this.parseCsv(csvText);
    }

    /**
     * Parse CSV text into structured data with quality validation
     * @param {string} csvText CSV content
     * @returns {Array} Parsed data points
     */
    parseCsv(csvText) {
        // Remove BOM if present and normalize line endings
        const cleanedText = csvText.replace(/^\uFEFF/, '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        const lines = cleanedText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        const data = [];
        const issues = [];

        // Find column indices (handle different CSV formats)
        const timestampIndex = this.findColumnIndex(headers, ['timestamp']);
        const basefeeWeiIndex = this.findColumnIndex(headers, ['basefee_wei']);
        const basefeeGweiIndex = this.findColumnIndex(headers, ['basefee_gwei']);
        const blockNumberIndex = this.findColumnIndex(headers, ['block_number']);

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // Skip empty lines

            const row = line.split(',').map(cell => cell.trim());
            if (row.length >= headers.length) {
                const dataPoint = {
                    timestamp: row[timestampIndex],
                    basefee_wei: parseFloat(row[basefeeWeiIndex]),
                    basefee_gwei: parseFloat(row[basefeeGweiIndex]),
                    block_number: row[blockNumberIndex],
                    row_number: i + 1
                };

                // Data quality validation
                const rowIssues = this.validateDataPoint(dataPoint, i + 1);
                if (rowIssues.length > 0) {
                    issues.push(...rowIssues);
                }

                data.push(dataPoint);
            } else {
                issues.push(`Row ${i + 1}: Insufficient columns (${row.length}/${headers.length})`);
            }
        }

        // Perform additional data quality checks
        const additionalIssues = this.performDataQualityChecks(data);
        issues.push(...additionalIssues);

        // Log data quality results
        if (issues.length === 0) {
            console.log(`‚úÖ Data quality: EXCELLENT - No issues detected`);
        } else {
            console.warn(`‚ö†Ô∏è Data quality issues detected:`, issues);
            console.warn(`üîç Total issues: ${issues.length} across ${data.length} records`);
        }

        return data;
    }

    /**
     * Validate individual data point
     * @param {Object} dataPoint Data point to validate
     * @param {number} rowNum Row number for error reporting
     * @returns {Array} Array of issues found
     */
    validateDataPoint(dataPoint, rowNum) {
        const issues = [];

        // Check for missing values
        if (!dataPoint.timestamp || dataPoint.timestamp.trim() === '') {
            issues.push(`Row ${rowNum}: Missing timestamp`);
        }
        if (isNaN(dataPoint.basefee_wei) || dataPoint.basefee_wei < 0) {
            issues.push(`Row ${rowNum}: Invalid basefee_wei: ${dataPoint.basefee_wei}`);
        }
        if (isNaN(dataPoint.basefee_gwei) || dataPoint.basefee_gwei < 0) {
            issues.push(`Row ${rowNum}: Invalid basefee_gwei: ${dataPoint.basefee_gwei}`);
        }
        if (!dataPoint.block_number || dataPoint.block_number.trim() === '') {
            issues.push(`Row ${rowNum}: Missing block_number`);
        }

        // Check for unrealistic basefee values
        if (dataPoint.basefee_gwei > 10000) {
            issues.push(`Row ${rowNum}: Unrealistically high basefee: ${dataPoint.basefee_gwei} gwei`);
        }
        if (dataPoint.basefee_gwei > 0 && dataPoint.basefee_gwei < 0.001) {
            issues.push(`Row ${rowNum}: Unrealistically low basefee: ${dataPoint.basefee_gwei} gwei`);
        }

        // Check wei/gwei consistency (allow 0.1% tolerance)
        const expectedGwei = dataPoint.basefee_wei / 1e9;
        const tolerance = Math.max(expectedGwei * 0.001, 0.000001);
        if (Math.abs(dataPoint.basefee_gwei - expectedGwei) > tolerance) {
            issues.push(`Row ${rowNum}: Wei/Gwei mismatch: ${dataPoint.basefee_wei} wei ‚â† ${dataPoint.basefee_gwei} gwei`);
        }

        return issues;
    }

    /**
     * Perform comprehensive data quality checks
     * @param {Array} data Dataset to check
     * @returns {Array} Array of issues found
     */
    performDataQualityChecks(data) {
        const issues = [];

        if (data.length === 0) {
            issues.push('Dataset is empty');
            return issues;
        }

        // Check for large basefee jumps (potential data corruption)
        let prevFee = null;
        for (let i = 0; i < data.length; i++) {
            const currentFee = data[i].basefee_gwei;
            if (prevFee !== null && currentFee > 0 && prevFee > 0) {
                const ratio = currentFee / prevFee;
                if (ratio > 10 || ratio < 0.1) {
                    issues.push(`Rows ${i}-${i+1}: Large basefee jump: ${prevFee.toFixed(3)} ‚Üí ${currentFee.toFixed(3)} gwei (${ratio.toFixed(1)}x)`);
                }
            }
            prevFee = currentFee;
        }

        // Check timestamp ordering
        for (let i = 1; i < data.length; i++) {
            const prevTime = new Date(data[i-1].timestamp);
            const currTime = new Date(data[i].timestamp);
            if (currTime <= prevTime) {
                issues.push(`Rows ${i}-${i+1}: Timestamps not in ascending order`);
            }
        }

        // Calculate basic statistics for anomaly detection
        const basefees = data.map(d => d.basefee_gwei).filter(f => f > 0);
        if (basefees.length > 0) {
            const mean = basefees.reduce((a, b) => a + b) / basefees.length;
            const std = Math.sqrt(basefees.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / basefees.length);
            const outlierThreshold = mean + 5 * std;

            const outliers = data.filter(d => d.basefee_gwei > outlierThreshold);
            if (outliers.length > 0) {
                issues.push(`Statistical outliers detected: ${outliers.length} values >5œÉ from mean`);
            }
        }

        return issues;
    }

    /**
     * Find column index by name variants
     * @param {Array} headers Header names
     * @param {Array} possibleNames Possible column names
     * @returns {number} Column index
     */
    findColumnIndex(headers, possibleNames) {
        for (const name of possibleNames) {
            const index = headers.findIndex(h => h.toLowerCase().includes(name.toLowerCase()));
            if (index !== -1) return index;
        }
        throw new Error(`Could not find column matching any of: ${possibleNames.join(', ')}`);
    }

    /**
     * Get dataset by name
     * @param {string} name Dataset name
     * @returns {Array} Dataset
     */
    getDataset(name) {
        if (!this.loaded) {
            throw new Error('Datasets not loaded yet. Call loadAllDatasets() first.');
        }
        return this.datasets[name];
    }

    /**
     * Get all dataset names
     * @returns {Array} Dataset names
     */
    getDatasetNames() {
        return Object.keys(this.datasetPaths);
    }

    /**
     * Get dataset statistics
     * @param {string} name Dataset name
     * @returns {Object} Statistics
     */
    getDatasetStats(name) {
        const data = this.getDataset(name);
        const basefees = data.map(d => d.basefee_gwei);

        return {
            name: name,
            count: data.length,
            duration_hours: data.length * 2 / 3600, // Assuming 2s per step
            min_basefee_gwei: Math.min(...basefees),
            max_basefee_gwei: Math.max(...basefees),
            avg_basefee_gwei: basefees.reduce((a, b) => a + b, 0) / basefees.length,
            median_basefee_gwei: this.median(basefees),
            std_basefee_gwei: this.standardDeviation(basefees)
        };
    }

    /**
     * Calculate median
     * @param {Array} arr Numbers
     * @returns {number} Median
     */
    median(arr) {
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    /**
     * Calculate standard deviation
     * @param {Array} arr Numbers
     * @returns {number} Standard deviation
     */
    standardDeviation(arr) {
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
        return Math.sqrt(variance);
    }

    /**
     * Get combined statistics for all datasets
     * @returns {Object} Combined statistics
     */
    getAllDatasetStats() {
        const stats = {};
        for (const name of this.getDatasetNames()) {
            stats[name] = this.getDatasetStats(name);
        }
        return stats;
    }

    /**
     * Show data loading status message in UI
     * @param {string} message Status message
     * @param {string} type Status type: 'loading', 'success', 'error'
     */
    showDataLoadingStatus(message, type) {
        // Try to find existing status element or create one
        let statusElement = document.getElementById('data-loading-status');

        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'data-loading-status';
            statusElement.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 12px 16px;
                border-radius: 6px;
                font-family: monospace;
                font-size: 14px;
                font-weight: bold;
                z-index: 10000;
                max-width: 400px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                transition: opacity 0.3s ease;
            `;

            // Insert at top of body
            if (document.body) {
                document.body.insertBefore(statusElement, document.body.firstChild);
            }
        }

        // Set styling based on type
        const styles = {
            loading: { bg: '#e3f2fd', border: '#2196f3', color: '#0d47a1' },
            success: { bg: '#e8f5e8', border: '#4caf50', color: '#2e7d32' },
            error: { bg: '#ffebee', border: '#f44336', color: '#c62828' }
        };

        const style = styles[type] || styles.error;
        statusElement.style.backgroundColor = style.bg;
        statusElement.style.border = `2px solid ${style.border}`;
        statusElement.style.color = style.color;
        statusElement.textContent = message;
        statusElement.style.opacity = '1';

        // Auto-hide success/error messages after delay
        if (type !== 'loading') {
            setTimeout(() => {
                if (statusElement) {
                    statusElement.style.opacity = '0';
                    setTimeout(() => {
                        if (statusElement && statusElement.parentNode) {
                            statusElement.parentNode.removeChild(statusElement);
                        }
                    }, 300);
                }
            }, type === 'success' ? 3000 : 8000);
        }
    }
}

// Global instance
window.historicalDataLoader = new HistoricalDataLoader();

// === taiko-simulator-js.js ===
/**
 * JavaScript Implementation of the Taiko Fee Mechanism Simulator
 * Based on the Python implementation in src/core/improved_simulator.py
 */

/**
 * Fee Vault implementation
 */
class FeeVault {
    constructor(initialBalance, target) {
        this.balance = initialBalance;
        this.target = target;
    }

    get deficit() {
        return Math.max(0, this.target - this.balance);
    }

    get surplus() {
        return Math.max(0, this.balance - this.target);
    }

    collectFees(amount) {
        this.balance += amount;
    }

    payL1Costs(amount) {
        this.balance -= amount;
    }
}

/**
 * Improved Fee Vault with enhanced functionality
 */
class ImprovedFeeVault extends FeeVault {
    constructor(initialBalance, target) {
        super(initialBalance, target);
        this.history = {
            balance: [initialBalance],
            deficit: [this.deficit],
            surplus: [this.surplus]
        };
    }

    collectFees(amount) {
        super.collectFees(amount);
        this.recordState();
    }

    payL1Costs(amount) {
        super.payL1Costs(amount);
        this.recordState();
    }

    recordState() {
        this.history.balance.push(this.balance);
        this.history.deficit.push(this.deficit);
        this.history.surplus.push(this.surplus);
    }
}

/**
 * Simulation Parameters
 */
class SimulationParams {
    constructor(options = {}) {
        // Fee mechanism parameters
        this.mu = options.mu || 0.0;           // L1 weight
        this.nu = options.nu || 0.1;           // Deficit weight
        this.H = options.H || 36;              // Prediction horizon (steps)

        // System parameters
        this.txs_per_batch = options.txs_per_batch || 100;
        // Implement documented formula: max(200,000/Expected Tx Volume, 2,000)
        const expectedTxVolume = this.txs_per_batch || 100;
        this.gas_per_tx = Math.max(200000 / expectedTxVolume, 2000);
        this.gas_per_batch = this.gas_per_tx * this.txs_per_batch;
        this.target_balance = options.target_balance || 1.0;  // ETH
        this.base_l1_cost = options.base_l1_cost || 0.001;    // ETH per tx

        // Transaction demand parameters
        this.demand_elasticity = options.demand_elasticity || 0.5;
        this.base_tx_demand = options.base_tx_demand || 100;  // txs per step
        this.max_tx_demand = options.max_tx_demand || 1000;   // txs per step

        // Timing parameters (critical for realistic vault economics)
        this.time_step_seconds = options.time_step_seconds || 2;  // 2s per Taiko L2 block
        this.batch_interval_steps = options.batch_interval_steps || 6;  // L1 batch every 12s
    }
}

/**
 * Improved Simulation Parameters
 */
class ImprovedSimulationParams extends SimulationParams {
    constructor(options = {}) {
        super(options);
        this.initial_vault_balance = options.initial_vault_balance || this.target_balance;
        this.total_steps = options.total_steps || 1800;  // Default 1 hour at 2s per step
    }
}

/**
 * Research Taiko Fee Simulator (for multi-scenario evaluation)
 */
class ResearchTaikoFeeSimulator {
    constructor(params, historicalData) {
        this.params = params;
        this.historicalData = historicalData;  // Array of {basefee_gwei, timestamp} objects
        this.vault = new FeeVault(params.target_balance, params.target_balance);

        this.resetState();
    }

    resetState() {
        this.vault = new FeeVault(this.params.target_balance, this.params.target_balance);
        this.timeStep = 0;

        // History tracking
        this.history = {
            time_step: [],
            l1_basefee: [],
            estimated_l1_cost: [],
            estimated_fee: [],
            transaction_volume: [],
            vault_balance: [],
            vault_deficit: [],
            fee_collected: [],
            l1_cost_paid: [],
            batch_occurred: [],
            deficit_ratio: []
        };

        // L1 cost estimation (EWMA)
        this.l1CostEwma = this.params.base_l1_cost;
        this.ewmaAlpha = 0.1;
    }

    /**
     * Estimate L1 cost per transaction based on current basefee
     */
    estimateL1CostPerTx(l1BasefeeGwei) {
        const l1BasefeeWei = l1BasefeeGwei * 1e9;
        const costPerTx = l1BasefeeWei * this.params.gas_per_tx / 1e18;  // Convert to ETH

        // Update EWMA estimate
        this.l1CostEwma = (1 - this.ewmaAlpha) * this.l1CostEwma + this.ewmaAlpha * costPerTx;
        return this.l1CostEwma;
    }

    /**
     * Calculate estimated fee using the Taiko mechanism
     */
    calculateEstimatedFee(l1CostEstimate) {
        // Direct L1 cost component
        const l1Component = this.params.mu * l1CostEstimate;

        // Deficit correction component with H-step prediction
        const deficit = this.vault.deficit;
        const target = this.params.target_balance;

        // Deficit component following documented formula: ŒΩ√óD/H
        let deficitComponent = 0;
        if (deficit > 0) {
            deficitComponent = this.params.nu * deficit / this.params.H;
        }

        return l1Component + deficitComponent;
    }

    /**
     * Calculate transaction volume based on fee with elasticity
     */
    calculateTransactionVolume(estimatedFee) {
        // Simple demand curve with elasticity
        const baseFee = 0.001;  // Base reference fee (ETH)
        const feeRatio = estimatedFee / baseFee;
        const demandMultiplier = Math.pow(feeRatio, -this.params.demand_elasticity);

        const volume = this.params.base_tx_demand * demandMultiplier;
        return Math.min(volume, this.params.max_tx_demand);
    }

    /**
     * Calculate L1 batch cost when batch is submitted
     */
    calculateL1BatchCost(l1BasefeeGwei) {
        const l1BasefeeWei = l1BasefeeGwei * 1e9;
        return l1BasefeeWei * this.params.gas_per_batch / 1e18;  // Convert to ETH
    }

    /**
     * Execute one simulation time step
     */
    step(l1BasefeeGwei) {
        // Estimate L1 cost per transaction
        const l1CostEstimate = this.estimateL1CostPerTx(l1BasefeeGwei);

        // Calculate estimated fee
        const estimatedFee = this.calculateEstimatedFee(l1CostEstimate);

        // Calculate transaction volume (with fee elasticity)
        const txVolume = this.calculateTransactionVolume(estimatedFee);

        // ALWAYS collect fees (every 2s Taiko L2 block)
        const totalFees = estimatedFee * txVolume;
        this.vault.collectFees(totalFees);

        // ONLY pay L1 costs when batch is submitted (every 12s = every 6 Taiko steps)
        const batchOccurred = (this.timeStep % this.params.batch_interval_steps === 0);
        let l1CostPaid = 0;
        if (batchOccurred) {
            l1CostPaid = this.calculateL1BatchCost(l1BasefeeGwei);
            this.vault.payL1Costs(l1CostPaid);
        }

        // Record history
        this.history.time_step.push(this.timeStep);
        this.history.l1_basefee.push(l1BasefeeGwei);
        this.history.estimated_l1_cost.push(l1CostEstimate);
        this.history.estimated_fee.push(estimatedFee);
        this.history.transaction_volume.push(txVolume);
        this.history.vault_balance.push(this.vault.balance);
        this.history.vault_deficit.push(this.vault.deficit);
        this.history.fee_collected.push(totalFees);
        this.history.l1_cost_paid.push(l1CostPaid);
        this.history.batch_occurred.push(batchOccurred);
        this.history.deficit_ratio.push(this.vault.deficit / this.params.target_balance);

        this.timeStep++;
    }

    /**
     * Run complete simulation on historical data
     */
    runSimulation(maxSteps = null) {
        this.resetState();

        const dataLength = this.historicalData.length;
        const totalSteps = maxSteps || Math.min(dataLength, this.params.total_steps || dataLength);

        for (let i = 0; i < totalSteps && i < dataLength; i++) {
            const dataPoint = this.historicalData[i];
            this.step(dataPoint.basefee_gwei);
        }

        return this.history;
    }

    /**
     * Get simulation results summary
     */
    getResultsSummary() {
        if (this.history.time_step.length === 0) {
            throw new Error('No simulation data available. Run simulation first.');
        }

        const fees = this.history.estimated_fee;
        const deficits = this.history.vault_deficit;
        const balances = this.history.vault_balance;

        return {
            steps: this.history.time_step.length,
            avg_fee_eth: fees.reduce((a, b) => a + b, 0) / fees.length,
            max_fee_eth: Math.max(...fees),
            min_fee_eth: Math.min(...fees),
            avg_deficit: deficits.reduce((a, b) => a + b, 0) / deficits.length,
            max_deficit: Math.max(...deficits),
            final_balance: balances[balances.length - 1],
            deficit_duration: deficits.filter(d => d > 0).length,
            insolvency_events: balances.filter(b => b < 0).length
        };
    }
}

/**
 * Improved Research Taiko Fee Simulator with enhanced features
 */
class ImprovedResearchTaikoFeeSimulator extends ResearchTaikoFeeSimulator {
    constructor(params, historicalData) {
        super(params, historicalData);
        this.improvedParams = params;

        // Enhanced state tracking
        this.l1CostHistory = [];
        this.l1BasefeeHistory = [];
        this.trendBasefee = null;
        this.previousEstimatedFee = null;

        this.resetState();
    }

    resetState() {
        super.resetState();

        // Use improved vault
        this.vault = new ImprovedFeeVault(
            this.improvedParams.initial_vault_balance,
            this.improvedParams.target_balance
        );

        this.l1CostHistory = [];
        this.l1BasefeeHistory = [];
        this.trendBasefee = null;
        this.previousEstimatedFee = null;
    }

    /**
     * Enhanced L1 cost estimation with trend analysis
     */
    estimateL1CostPerTx(l1BasefeeGwei) {
        // Track L1 basefee history for trend calculation
        this.l1BasefeeHistory.push(l1BasefeeGwei);

        // Keep only recent history for trend calculation
        const trendWindow = 20;
        if (this.l1BasefeeHistory.length > trendWindow) {
            this.l1BasefeeHistory = this.l1BasefeeHistory.slice(-trendWindow);
        }

        // Calculate trend basefee (EWMA)
        if (this.l1BasefeeHistory.length >= 3) {
            if (this.trendBasefee === null) {
                // Initialize with mean of first few points
                this.trendBasefee = this.l1BasefeeHistory.reduce((a, b) => a + b, 0) / this.l1BasefeeHistory.length;
            } else {
                // Update EWMA trend with alpha = 0.15
                const alphaTrend = 0.15;
                this.trendBasefee = alphaTrend * l1BasefeeGwei + (1 - alphaTrend) * this.trendBasefee;
            }
        } else {
            this.trendBasefee = l1BasefeeGwei;
        }

        // Use trend basefee for cost calculation instead of spot price
        const rawCost = this.trendBasefee * 1e9 * this.params.gas_per_tx / 1e18;

        // Add to cost history for outlier rejection
        this.l1CostHistory.push(rawCost);
        if (this.l1CostHistory.length > 50) {
            this.l1CostHistory = this.l1CostHistory.slice(-50);
        }

        // Simple outlier rejection (remove top 10% outliers)
        const sortedCosts = [...this.l1CostHistory].sort((a, b) => a - b);
        const percentile90 = sortedCosts[Math.floor(sortedCosts.length * 0.9)];
        const filteredCost = Math.min(rawCost, percentile90);

        // Update EWMA estimate with filtered cost
        this.l1CostEwma = (1 - this.ewmaAlpha) * this.l1CostEwma + this.ewmaAlpha * filteredCost;
        return this.l1CostEwma;
    }
}

// Export for global use
window.ResearchTaikoFeeSimulator = ResearchTaikoFeeSimulator;
window.ImprovedResearchTaikoFeeSimulator = ImprovedResearchTaikoFeeSimulator;
window.SimulationParams = SimulationParams;
window.ImprovedSimulationParams = ImprovedSimulationParams;

// === metrics-framework-js.js ===
/**
 * JavaScript Implementation of the Enhanced Metrics Framework
 * Based on the Python implementation in src/analysis/enhanced_metrics.py
 */

/**
 * Enhanced Metrics Calculator
 * Implements the rigorous mathematical framework for evaluating Taiko fee mechanism performance
 */
class EnhancedMetricsCalculator {
    constructor(targetBalance = 1.0, taikoBlockTime = 2.0, ethBlockTime = 12.0) {
        this.targetBalance = targetBalance;
        this.taikoBlockTime = taikoBlockTime;
        this.ethBlockTime = ethBlockTime;

        // Risk thresholds
        this.insolvencyThreshold = 0.1 * targetBalance;  // 10% deficit is insolvency risk
        this.extremeFeeThreshold = 0.01;                 // 0.01 ETH fee is extreme
    }

    /**
     * Calculate user experience metrics
     * These metrics directly impact user adoption and protocol competitiveness
     */
    calculateUserExperienceMetrics(simulationResults) {
        const fees = simulationResults.estimated_fee;
        const timeSteps = fees.length;

        // Fee Affordability: Heavily penalize high fees using log scale
        // Formula: -log(1 + avg_fee_eth √ó 1000)
        const avgFee = this.mean(fees);
        const feeAffordability = avgFee > 0 ? -Math.log(1 + avgFee * 1000) : 1.0;

        // Fee Predictability: Reward stable fees
        // Formula: 1 - coefficient_of_variation
        const feeCv = this.std(fees) / this.mean(fees);
        const feePredictability = Math.max(0, 1 - feeCv);

        // Fee Stability: Lower relative volatility = better UX
        // Formula: 1 - coefficient_of_variation (same as predictability but conceptually different)
        const feeStability = feePredictability;

        // Fee Predictability over 1-hour windows (30 steps at 2s per step)
        const oneHourSteps = Math.floor(3600 / this.taikoBlockTime);  // 1800 steps
        const feePredictability1h = this.calculateWindowPredictability(fees, oneHourSteps);

        // Fee Predictability over 6-hour windows (180 steps)
        const sixHourSteps = Math.floor(6 * 3600 / this.taikoBlockTime);  // 10800 steps
        const feePredictability6h = this.calculateWindowPredictability(fees, sixHourSteps);

        // Fee Rate of Change (95th percentile)
        const feeRateOfChangeP95 = this.calculateFeeRateOfChangeP95(fees);

        // User Cost Burden (simplified calculation)
        const totalUserFees = fees.reduce((sum, fee, i) => {
            const txVolume = simulationResults.transaction_volume[i] || 0;
            return sum + fee * txVolume;
        }, 0);
        const userCostBurden = totalUserFees / (timeSteps * avgFee * 100); // Normalized

        return {
            fee_affordability_score: feeAffordability,
            fee_predictability_score: feePredictability,
            fee_stability_score: feeStability,
            fee_predictability_1h: feePredictability1h,
            fee_predictability_6h: feePredictability6h,
            fee_rate_of_change_p95: feeRateOfChangeP95,
            user_cost_burden: userCostBurden
        };
    }

    /**
     * Calculate protocol stability metrics
     * Critical for protocol security and robustness
     */
    calculateProtocolStabilityMetrics(simulationResults) {
        const vaultBalances = simulationResults.vault_balance;
        const vaultDeficits = simulationResults.vault_deficit;
        const timeSteps = vaultBalances.length;

        // Insolvency Probability: P(vault_balance < critical_threshold)
        const insolvencyEvents = vaultBalances.filter(balance => balance < this.insolvencyThreshold).length;
        const insolvencyProbability = insolvencyEvents / timeSteps;

        // Deficit Weighted Duration: ‚àë(deficit_magnitude √ó duration)¬≤ / total_time
        const deficitWeightedDuration = this.calculateDeficitWeightedDuration(vaultDeficits, timeSteps);

        // Vault Stress Resilience: Average recovery rate during deficit periods
        const stressResilience = this.calculateStressResilience(vaultDeficits, vaultBalances);

        // Max Continuous Underfunding
        const maxContinuousUnderfunding = this.calculateMaxContinuousUnderfunding(vaultDeficits);

        // Vault Robustness Score: 1 - P(deficit > 0.5√ótarget_balance)
        const severeDeficitEvents = vaultDeficits.filter(deficit => deficit > 0.5 * this.targetBalance).length;
        const vaultRobustnessScore = 1 - (severeDeficitEvents / timeSteps);

        // Crisis Resilience Score: 1 - max_deficit_duration / simulation_length
        const maxDeficit = Math.max(...vaultDeficits);
        const crisisResilienceScore = Math.max(0, 1 - maxDeficit / this.targetBalance);

        return {
            insolvency_probability: insolvencyProbability,
            deficit_weighted_duration: deficitWeightedDuration,
            vault_stress_resilience: stressResilience,
            max_continuous_underfunding: maxContinuousUnderfunding,
            vault_robustness_score: vaultRobustnessScore,
            crisis_resilience_score: crisisResilienceScore
        };
    }

    /**
     * Calculate economic efficiency metrics
     */
    calculateEconomicEfficiencyMetrics(simulationResults) {
        const vaultBalances = simulationResults.vault_balance;
        const feeCollected = simulationResults.fee_collected;
        const l1CostPaid = simulationResults.l1_cost_paid;

        // Capital Efficiency: Average vault utilization
        const avgBalance = this.mean(vaultBalances);
        const capitalEfficiency = Math.min(avgBalance / this.targetBalance, 2.0); // Cap at 200%

        // Cost Recovery Efficiency
        const totalFeesCollected = this.sum(feeCollected);
        const totalL1Costs = this.sum(l1CostPaid);
        const costRecoveryEfficiency = totalL1Costs > 0 ? totalFeesCollected / totalL1Costs : 1.0;

        return {
            capital_efficiency_score: capitalEfficiency,
            cost_recovery_efficiency: costRecoveryEfficiency
        };
    }

    /**
     * Calculate composite scores for multi-objective optimization
     */
    calculateCompositeScores(allMetrics) {
        // UX Score weights (focused on what users actually care about)
        const uxScore =
            0.4 * allMetrics.fee_affordability_score +
            0.3 * allMetrics.fee_stability_score +
            0.15 * allMetrics.fee_predictability_1h +
            0.15 * allMetrics.fee_predictability_6h;

        // Safety Score weights (protocol solvency risks)
        const safetyScore =
            0.4 * (1 - allMetrics.insolvency_probability) +
            0.3 * (1 - allMetrics.deficit_weighted_duration) +
            0.3 * allMetrics.vault_stress_resilience;

        // Efficiency Score
        const efficiencyScore =
            0.6 * allMetrics.capital_efficiency_score +
            0.4 * allMetrics.cost_recovery_efficiency;

        // Overall Score (weighted combination)
        const overallScore =
            0.5 * uxScore +
            0.35 * safetyScore +
            0.15 * efficiencyScore;

        return {
            user_experience_composite: uxScore,
            protocol_stability_composite: safetyScore,
            economic_efficiency_composite: efficiencyScore,
            overall_optimization_score: overallScore,
            ux_score: uxScore,  // Alias for consistency
            safety_score: safetyScore  // Alias for consistency
        };
    }

    /**
     * Calculate all metrics for a simulation result
     */
    calculateAllMetrics(simulationResults, params = {}) {
        const uxMetrics = this.calculateUserExperienceMetrics(simulationResults);
        const stabilityMetrics = this.calculateProtocolStabilityMetrics(simulationResults);
        const efficiencyMetrics = this.calculateEconomicEfficiencyMetrics(simulationResults);

        // Combine all metrics
        const allMetrics = {
            ...uxMetrics,
            ...stabilityMetrics,
            ...efficiencyMetrics
        };

        // Calculate composite scores
        const compositeScores = this.calculateCompositeScores(allMetrics);

        return {
            ...allMetrics,
            ...compositeScores
        };
    }

    // === Helper Methods ===

    /**
     * Calculate mean of array
     */
    mean(arr) {
        return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
    }

    /**
     * Calculate standard deviation of array
     */
    std(arr) {
        const mean = this.mean(arr);
        const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
        return Math.sqrt(variance);
    }

    /**
     * Calculate sum of array
     */
    sum(arr) {
        return arr.reduce((a, b) => a + b, 0);
    }

    /**
     * Calculate percentile
     */
    percentile(arr, p) {
        const sorted = [...arr].sort((a, b) => a - b);
        const index = Math.floor(sorted.length * p / 100);
        return sorted[Math.min(index, sorted.length - 1)];
    }

    /**
     * Calculate window-based predictability
     */
    calculateWindowPredictability(fees, windowSize) {
        if (fees.length < windowSize) return 1.0;

        let totalPredictability = 0;
        let windowCount = 0;

        for (let i = 0; i <= fees.length - windowSize; i++) {
            const window = fees.slice(i, i + windowSize);
            const windowCv = this.std(window) / this.mean(window);
            totalPredictability += Math.max(0, 1 - windowCv);
            windowCount++;
        }

        return windowCount > 0 ? totalPredictability / windowCount : 1.0;
    }

    /**
     * Calculate 95th percentile of fee rate of change
     */
    calculateFeeRateOfChangeP95(fees) {
        if (fees.length < 2) return 0;

        const rateChanges = [];
        for (let i = 1; i < fees.length; i++) {
            if (fees[i-1] > 0) {
                const change = Math.abs(fees[i] - fees[i-1]) / fees[i-1];
                rateChanges.push(change);
            }
        }

        return rateChanges.length > 0 ? this.percentile(rateChanges, 95) : 0;
    }

    /**
     * Calculate deficit weighted duration
     */
    calculateDeficitWeightedDuration(deficits, totalTime) {
        let weightedSum = 0;
        let currentDeficitRun = 0;

        for (const deficit of deficits) {
            if (deficit > 0) {
                currentDeficitRun++;
                weightedSum += Math.pow(deficit * currentDeficitRun, 2);
            } else {
                currentDeficitRun = 0;
            }
        }

        return weightedSum / totalTime;
    }

    /**
     * Calculate stress resilience
     */
    calculateStressResilience(deficits, balances) {
        let recoveryEvents = 0;
        let totalRecoveryRate = 0;

        for (let i = 1; i < deficits.length; i++) {
            if (deficits[i-1] > 0 && deficits[i] < deficits[i-1]) {
                const recoveryRate = (deficits[i-1] - deficits[i]) / Math.max(deficits[i-1], 0.001);
                totalRecoveryRate += recoveryRate;
                recoveryEvents++;
            }
        }

        return recoveryEvents > 0 ? totalRecoveryRate / recoveryEvents : 0;
    }

    /**
     * Calculate maximum continuous underfunding
     */
    calculateMaxContinuousUnderfunding(deficits) {
        let maxContinuous = 0;
        let currentContinuous = 0;

        for (const deficit of deficits) {
            if (deficit > 0) {
                currentContinuous++;
                maxContinuous = Math.max(maxContinuous, currentContinuous);
            } else {
                currentContinuous = 0;
            }
        }

        return maxContinuous;
    }
}

/**
 * Multi-Scenario Evaluator
 * Evaluates parameter sets across multiple historical scenarios
 */
class MultiScenarioEvaluator {
    constructor(historicalDataLoader, metricsCalculator) {
        this.historicalDataLoader = historicalDataLoader;
        this.metricsCalculator = metricsCalculator;
    }

    /**
     * Evaluate a parameter set across all historical scenarios
     */
    async evaluateParameterSet(params) {
        if (!this.historicalDataLoader.loaded) {
            throw new Error('Historical data not loaded. Call historicalDataLoader.loadAllDatasets() first.');
        }

        const results = {};
        const datasetNames = this.historicalDataLoader.getDatasetNames();

        for (const datasetName of datasetNames) {
            const dataset = this.historicalDataLoader.getDataset(datasetName);

            // Create simulation parameters
            const simulationParams = new ImprovedSimulationParams({
                mu: params.mu,
                nu: params.nu,
                H: params.H,
                total_steps: Math.min(dataset.length, 1800) // Limit to reasonable size
            });

            // Run simulation
            const simulator = new ImprovedResearchTaikoFeeSimulator(simulationParams, dataset);
            const simulationResults = simulator.runSimulation();

            // Calculate metrics
            const metrics = this.metricsCalculator.calculateAllMetrics(simulationResults, params);

            results[datasetName] = {
                simulationResults: simulationResults,
                metrics: metrics,
                summary: simulator.getResultsSummary()
            };
        }

        // Calculate aggregated metrics across all scenarios
        const aggregatedMetrics = this.aggregateMetricsAcrossScenarios(results);

        return {
            individual_scenarios: results,
            aggregated_metrics: aggregatedMetrics,
            parameters: params
        };
    }

    /**
     * Aggregate metrics across all scenarios
     */
    aggregateMetricsAcrossScenarios(scenarioResults) {
        const datasetNames = Object.keys(scenarioResults);
        const aggregated = {};

        // Get all metric names from first scenario
        const firstScenario = scenarioResults[datasetNames[0]];
        const metricNames = Object.keys(firstScenario.metrics);

        // Calculate mean and worst-case for each metric
        for (const metricName of metricNames) {
            const values = datasetNames.map(name => scenarioResults[name].metrics[metricName]);

            aggregated[`${metricName}_mean`] = this.metricsCalculator.mean(values);
            aggregated[`${metricName}_min`] = Math.min(...values);
            aggregated[`${metricName}_max`] = Math.max(...values);
            aggregated[`${metricName}_std`] = this.metricsCalculator.std(values);
        }

        // Calculate robust composite scores (using worst-case scenarios)
        aggregated.robust_ux_score = Math.min(
            ...datasetNames.map(name => scenarioResults[name].metrics.ux_score)
        );

        aggregated.robust_safety_score = Math.min(
            ...datasetNames.map(name => scenarioResults[name].metrics.safety_score)
        );

        aggregated.robust_overall_score =
            0.5 * aggregated.robust_ux_score +
            0.5 * aggregated.robust_safety_score;

        return aggregated;
    }
}

// Export for global use
window.EnhancedMetricsCalculator = EnhancedMetricsCalculator;
window.MultiScenarioEvaluator = MultiScenarioEvaluator;

// === simulator.js ===
// Taiko Fee Mechanism Simulator - JavaScript Implementation
// Ported from Python analysis for web interface

class EIP1559BaseFeeSimulator {
    constructor(mu, sigma, initialValue = 10e9, seed = 42) {
        this.mu = mu;           // Drift (trend)
        this.sigma = sigma;     // Volatility
        this.currentBaseFee = initialValue;  // Current basefee in wei
        this.seed = seed;       // Random seed for reproducible results
        this.rng = this.seedableRandom(seed);

        // EIP-1559 constants (updated 2024 values)
        this.TARGET_GAS = 18_000_000;  // 18M gas target per block (current)
        this.MAX_GAS = 36_000_000;     // 36M gas max per block (current)
        this.BASE_FEE_MAX_CHANGE = 1.125;  // Max 12.5% change per block
    }

    step(dt = 1, timeStep = 0, spikeDelay = 0, spikeHeight = 0.3) {
        // Generate demand pressure based on volatility and spikes
        const randomShock = this.generateNormal(0, 1);
        let demandPressure = this.sigma * randomShock;

        // Add controlled spike after delay
        if (timeStep >= spikeDelay && timeStep < spikeDelay + 30) {
            // Create realistic spike wave that follows EIP-1559 limits
            const spikeProgress = (timeStep - spikeDelay) / 30;
            const spikeIntensity = spikeHeight * Math.sin(spikeProgress * Math.PI) * 2;
            demandPressure += spikeIntensity;
        }

        // Convert demand pressure to block gas usage
        // demandPressure > 0 = high demand, < 0 = low demand
        const normalizedDemand = Math.tanh(demandPressure); // Bound between -1 and 1
        const gasUsed = this.TARGET_GAS + (normalizedDemand * (this.MAX_GAS - this.TARGET_GAS) * 0.5);

        // EIP-1559 basefee adjustment formula
        const gasUsedDelta = gasUsed - this.TARGET_GAS;
        const baseFeePerGasDelta = Math.floor(this.currentBaseFee * gasUsedDelta / this.TARGET_GAS / 8);

        // Apply the change with EIP-1559 limits
        let newBaseFee = this.currentBaseFee + baseFeePerGasDelta;

        // Enforce max change rate (12.5% per block)
        const maxIncrease = this.currentBaseFee * this.BASE_FEE_MAX_CHANGE;
        const maxDecrease = this.currentBaseFee / this.BASE_FEE_MAX_CHANGE;

        newBaseFee = Math.min(newBaseFee, maxIncrease);
        newBaseFee = Math.max(newBaseFee, maxDecrease);

        // Allow natural basefee dynamics for realistic sub-gwei periods
        // Removed artificial 1 gwei floor to match documented low-fee datasets (0.055-0.092 gwei)
        this.currentBaseFee = Math.max(newBaseFee, 1e6); // 0.001 gwei minimum (technical floor)

        return this.currentBaseFee;
    }

    seedableRandom(seed) {
        // Simple seedable random number generator (LCG)
        let state = seed;
        return () => {
            state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
            return state / Math.pow(2, 32);
        };
    }

    generateNormal(mean, std) {
        // Box-Muller transform for normal distribution using seeded random
        let u = 0, v = 0;
        while(u === 0) u = this.rng(); // Converting [0,1) to (0,1)
        while(v === 0) v = this.rng();
        return mean + std * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
}

// Historical data cache
const HISTORICAL_DATA = {
    may2023: null,
    recent: null,
    may2022: null,
    june2022: null
};

// Data file mapping
const DATA_FILES = {
    may2023: 'data_cache/may_2023_pepe_crisis_data.csv',
    recent: 'data_cache/recent_low_fees_3hours.csv',
    may2022: 'data_cache/luna_crash_true_peak_contiguous.csv',
    june2022: 'data_cache/real_july_2022_spike_data.csv'
    // Note: All periods are post-EIP-1559 with valid basefee data (EIP-1559 activated Aug 5, 2021)
    // may2023 contains PEPE memecoin crisis data showing extreme volatility (60-184 gwei)
    // june2022 contains real July 1, 2022 data showing actual market volatility (7-88 gwei)
};

class TaikoFeeSimulator {
    constructor(params) {

        this.mu = params.mu;                    // L1 cost weight
        this.nu = params.nu;                    // Deficit weight
        this.H = params.H;                      // Time horizon
        this.targetBalance = params.targetBalance || 100;
        this.feeElasticity = params.feeElasticity || 0.2;
        this.minFee = params.minFee || 1e-8;

        // Guaranteed recovery parameters
        this.guaranteedRecovery = params.guaranteedRecovery || false;
        this.minDeficitRate = params.minDeficitRate || 1e-6; // Configurable minimum deficit correction rate

        // Debug constructor parameters
        console.log(`TaikoFeeSimulator initialized with guaranteedRecovery=${this.guaranteedRecovery}, minDeficitRate=${this.minDeficitRate}, mu=${this.mu}, nu=${this.nu}, H=${this.H}`);

        // Vault initialization
        this.vaultBalance = this.getInitialVaultBalance(params.vaultInit);

        // L1 data source configuration
        this.l1Source = params.l1Source || 'simulated';
        this.historicalPeriod = params.historicalPeriod || 'may2022';
        this.historicalData = null;
        this.historicalIndex = 0;


        // L1 model parameters (for simulated mode) - Use realistic 2025 basefee levels
        const realisticBasefee = 0.075e9; // 0.075 gwei in wei (realistic 2025 levels)
        this.l1Model = new EIP1559BaseFeeSimulator(0.0, params.l1Volatility, realisticBasefee, params.seed || 42);
        console.log(`L1 Simulator initialized with realistic basefee: ${realisticBasefee/1e9} gwei (was 10 gwei)`);
        this.spikeDelay = params.spikeDelaySteps || params.spikeDelay || 60;  // Use calculated steps or fallback
        this.spikeHeight = params.spikeHeight || 0.3;  // Spike intensity

        // Transaction parameters (aligned with Python implementation)
        this.txsPerBatch = params.txsPerBatch || 100;  // Transactions per L1 batch (matches Python default)
        this.batchGas = 200000;        // Gas cost for L1 batch submission

        // L1 basefee trend tracking for cost estimation
        this.l1BasefeeHistory = [];
        this.trendWindow = 20;  // 20-step window for trend calculation
        this.trendBasefee = null;  // Trend-based basefee estimate

        // Calculate gas per tx based on expected volume (economies of scale)
        this.updateGasPerTx();
    }

    updateGasPerTx() {
        // CORRECTED: max(200,000 / Expected Tx Volume, 200) - fixed from bug analysis
        // This implements economies of scale with a 200 gas minimum for overhead
        const baseGasPerTx = this.batchGas / this.txsPerBatch;
        this.gasPerTx = Math.max(baseGasPerTx, 200);

        console.log(`gasPerTx = max(${this.batchGas} / ${this.txsPerBatch}, 200) = max(${baseGasPerTx}, 200) = ${this.gasPerTx} gas`);
        console.log(`L1 cost per tx = basefee * ${this.gasPerTx} / 1e18`);
    }

    getInitialVaultBalance(vaultInit) {
        switch(vaultInit) {
            case 'target':
                return this.targetBalance;
            case 'underfunded-20':
                return this.targetBalance * 0.8;
            case 'underfunded-50':
                return this.targetBalance * 0.5;
            case 'overfunded-20':
                return this.targetBalance * 1.2;
            default:
                return this.targetBalance;
        }
    }

    updateL1BasefeeTrend(currentBasefeeWei) {
        // Add current basefee to history
        this.l1BasefeeHistory.push(currentBasefeeWei);

        // Maintain window size
        if (this.l1BasefeeHistory.length > this.trendWindow) {
            this.l1BasefeeHistory.shift();
        }

        // Calculate trend-based estimate (exponentially weighted moving average)
        if (this.l1BasefeeHistory.length >= 3) {
            // Use EWMA with alpha = 0.15 for smoothing
            const alpha = 0.15;
            if (this.trendBasefee === null) {
                // Initialize with simple average of first few points
                this.trendBasefee = this.l1BasefeeHistory.reduce((a, b) => a + b, 0) / this.l1BasefeeHistory.length;
            } else {
                this.trendBasefee = alpha * currentBasefeeWei + (1 - alpha) * this.trendBasefee;
            }
        } else {
            // Not enough history, use spot price
            this.trendBasefee = currentBasefeeWei;
        }
    }

    calculateL1Cost(l1BasefeeWei) {
        // Update trend tracking
        this.updateL1BasefeeTrend(l1BasefeeWei);

        // Use trend basefee for cost estimation instead of spot price
        const basefeeForCost = this.trendBasefee || l1BasefeeWei;

        // Calculate L1 cost per L2 transaction based on amortized batch costs
        return (basefeeForCost * this.gasPerTx) / 1e18;
    }

    calculateFee(l1BasefeeWei, vaultDeficit) {
        const l1Cost = this.calculateL1Cost(l1BasefeeWei);
        const l1Component = this.mu * l1Cost;

        let deficitComponent = this.nu * (vaultDeficit / this.H);

        // Apply guaranteed recovery logic if enabled
        if (this.guaranteedRecovery && vaultDeficit > 0) {
            // Ensure minimum deficit correction rate to prevent asymptotic stalling
            const standardCorrection = this.nu * (vaultDeficit / this.H);
            const minimumCorrection = this.minDeficitRate;
            const wasStandardUsed = standardCorrection >= minimumCorrection;
            deficitComponent = Math.max(standardCorrection, minimumCorrection);

            // Debug logging (log 2% of the time to monitor effectiveness)
            if (Math.random() < 0.02) {
                console.log(`Guaranteed Recovery: deficit=${vaultDeficit.toFixed(6)}, standard=${standardCorrection.toExponential(3)}, minimum=${minimumCorrection.toExponential(3)}, used=${deficitComponent.toExponential(3)}, source=${wasStandardUsed ? 'standard' : 'minimum'}`);
            }
        }

        return Math.max(l1Component + deficitComponent, this.minFee);
    }

    calculateDemand(fee, baseDemand = this.txsPerBatch) {
        // Simple demand model with price elasticity
        if (fee <= this.minFee) return baseDemand;

        const feeMultiplier = fee / this.minFee;
        const demandMultiplier = Math.pow(feeMultiplier, -this.feeElasticity);

        return baseDemand * demandMultiplier;
    }

    async loadHistoricalData() {
        if (this.l1Source !== 'historical') {
            return;
        }

        const period = this.historicalPeriod;

        // Check if already cached
        if (HISTORICAL_DATA[period]) {
            this.historicalData = HISTORICAL_DATA[period];
            this.historicalIndex = 0;
            return;
        }

        try {
            console.log(`Loading historical data for period: ${period}, file: ${DATA_FILES[period]}`);
            const response = await fetch(DATA_FILES[period]);
            if (!response.ok) {
                throw new Error(`Failed to load ${period} data: ${response.statusText}`);
            }

            const csvText = await response.text();
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            // Support any column order (e.g., Luna crash dataset uses block_number first)
            const colIndex = {
                timestamp: headers.indexOf('timestamp'),
                basefee_wei: headers.indexOf('basefee_wei'),
                basefee_gwei: headers.indexOf('basefee_gwei'),
                block_number: headers.indexOf('block_number')
            };

            const data = lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim());

                const getVal = (key, fallbackIdx) => {
                    const idx = colIndex[key];
                    return idx >= 0 ? values[idx] : values[fallbackIdx];
                };

                const timestamp = getVal('timestamp', 0);
                const basefeeWei = parseFloat(getVal('basefee_wei', 1));
                const basefeeGwei = parseFloat(getVal('basefee_gwei', 2));
                const rawBlock = getVal('block_number', 3);
                const blockNumber = (typeof rawBlock === 'string' && rawBlock.startsWith('0x'))
                    ? parseInt(rawBlock, 16)
                    : parseInt(rawBlock, 10);

                return {
                    timestamp,
                    basefee_wei: basefeeWei,
                    basefee_gwei: basefeeGwei,
                    block_number: blockNumber
                };
            });

            HISTORICAL_DATA[period] = data;
            this.historicalData = data;
            this.historicalIndex = 0;

            console.log(`Successfully loaded ${data.length} data points for ${period}. Basefee range: ${data[0]?.basefee_gwei?.toFixed(3)} - ${data[data.length-1]?.basefee_gwei?.toFixed(3)} gwei`);

        } catch (error) {
            console.error('Failed to load historical data:', error);
            // Fallback to simulated data
            this.l1Source = 'simulated';
        }
    }

    getNextL1Basefee() {
        if (this.l1Source === 'historical' && this.historicalData && this.historicalData.length > 0) {
            // Use modulo to cycle through historical data
            const dataPoint = this.historicalData[this.historicalIndex % this.historicalData.length];
            const basefeeGwei = dataPoint.basefee_wei / 1e9;
            this.historicalIndex++;
            return dataPoint.basefee_wei;
        } else {
            const simulatedBasefee = this.l1Model.step(1, this.historicalIndex, this.spikeDelay, this.spikeHeight);
            const simulatedGwei = simulatedBasefee / 1e9;
            this.historicalIndex++;
            return simulatedBasefee;
        }
    }

    async runSimulation(steps = 300) {
        // Load historical data if needed
        await this.loadHistoricalData();

        // Reset historical index to start from beginning of selected period
        this.historicalIndex = 0;

        // Track real elapsed seconds when using historical data
        let historicalStartTimestamp = null;
        if (this.l1Source === 'historical' && this.historicalData && this.historicalData.length > 0) {
            historicalStartTimestamp = new Date(this.historicalData[0].timestamp);
        }

        // For historical data, use the full length of available data instead of fixed steps
        const actualSteps = (this.l1Source === 'historical' && this.historicalData && this.historicalData.length > 0)
            ? this.historicalData.length
            : steps;

        const results = [];

        for (let t = 0; t < actualSteps; t++) {
            // Get current L1 basefee (and timestamp if historical)
            let l1Basefee;
            let l1ElapsedSeconds; // L1 block-time spacing (~12s) or real timestamps
            let l2ElapsedSeconds; // Taiko step spacing (2s)
            let timestampLabel = null;

            if (this.l1Source === 'historical' && this.historicalData && this.historicalData.length > 0) {
                const dataPoint = this.historicalData[this.historicalIndex % this.historicalData.length];
                l1Basefee = dataPoint.basefee_wei;
                timestampLabel = dataPoint.timestamp;

                if (historicalStartTimestamp) {
                    const currentTs = new Date(dataPoint.timestamp);
                    l1ElapsedSeconds = (currentTs - historicalStartTimestamp) / 1000;
                } else {
                    l1ElapsedSeconds = t * 12; // fallback if parsing fails
                }

                // For historical playback, align L2 timeline to real elapsed time to display correct duration
                l2ElapsedSeconds = l1ElapsedSeconds;

                this.historicalIndex++;
            } else {
                l1Basefee = this.getNextL1Basefee();

                // Simulated L1 steps represent ~12s block spacing
                l1ElapsedSeconds = t * 12;

                // Taiko step spacing remains 2s
                l2ElapsedSeconds = t * 2;
            }

            // Calculate vault deficit
            const vaultDeficit = Math.max(0, this.targetBalance - this.vaultBalance);

            // Calculate current fee
            const estimatedFee = this.calculateFee(l1Basefee, vaultDeficit);

            // Calculate transaction demand based on fee
            const txVolume = this.calculateDemand(estimatedFee);

            // Calculate fees collected (every 2s Taiko block)
            const feesCollected = estimatedFee * txVolume;

            // Determine if this is an L1 batch submission step (every 12s = every 6 Taiko steps)
            const isL1BatchStep = (t % 6 === 0);

            // Calculate actual L1 batch cost (only when batch is submitted)
            let actualL1Cost = 0;
            if (isL1BatchStep) {
                // Real L1 batch cost = L1 basefee √ó batch gas cost
                actualL1Cost = (l1Basefee * this.batchGas) / 1e18;
            }

            // Update vault balance with proper timing separation
            // Always collect fees (every 2s)
            this.vaultBalance += feesCollected;

            // Only pay L1 costs when batch is submitted (every 12s)
            if (isL1BatchStep) {
                this.vaultBalance -= actualL1Cost;
            }

            // Store results (include both spot and trend basefee for analysis)
            results.push({
                timeStep: t,
                l1ElapsedSeconds,
                l2ElapsedSeconds,
                timestampLabel,
                l1Basefee: l1Basefee,  // Spot basefee
                l1TrendBasefee: this.trendBasefee || l1Basefee,  // Trend basefee used for cost calculation
                vaultBalance: this.vaultBalance,
                vaultDeficit: vaultDeficit,
                estimatedFee: estimatedFee,
                txVolume: txVolume,
                feesCollected: feesCollected,
                actualL1Cost: actualL1Cost,
                isL1BatchStep: isL1BatchStep  // Track when L1 batch costs are paid
            });
        }

        return results;
    }
}

class MetricsCalculator {
    constructor(targetBalance, gasPerTx) {
        this.targetBalance = targetBalance;
        this.gasPerTx = gasPerTx;
    }

    calculateMetrics(simulationData) {
        // Convert per-transaction fees to per-gas fees for display
        const fees = simulationData.map(d => (d.estimatedFee * 1e9) / this.gasPerTx); // Convert to per-gas gwei
        const vaultBalances = simulationData.map(d => d.vaultBalance);
        const l1Basefees = simulationData.map(d => d.l1Basefee);

        // Average fee (now in per-gas gwei)
        const avgFee = this.mean(fees);

        // Fee coefficient of variation
        const feeStd = this.standardDeviation(fees);
        const feeCV = feeStd / avgFee;

        // Time underfunded percentage (with 0.01% threshold for meaningful underfunding)
        // Only deficits > 0.01% of target balance are considered meaningfully underfunded
        const significantDeficitThreshold = this.targetBalance * 0.0001; // 0.01% of target
        const underfundedSteps = vaultBalances.filter(balance =>
            (this.targetBalance - balance) > significantDeficitThreshold
        ).length;
        const timeUnderfundedPct = (underfundedSteps / simulationData.length) * 100;

        // L1 tracking error (simplified)
        const l1Costs = l1Basefees.map(basefee => (basefee * this.gasPerTx) / 1e18);
        const normalizedFees = fees.map(fee => fee / this.mean(fees));
        const normalizedL1Costs = l1Costs.map(cost => cost / this.mean(l1Costs));
        const trackingError = this.standardDeviation(normalizedFees.map((fee, i) => fee - normalizedL1Costs[i]));

        // 95th percentile fee (now in per-gas gwei)
        const sortedFees = [...fees].sort((a, b) => a - b);
        const fee95thPercentile = sortedFees[Math.floor(sortedFees.length * 0.95)];

        // Vault balance statistics
        const vaultBalanceStd = this.standardDeviation(vaultBalances);
        const maxDeficit = Math.max(...simulationData.map(d => d.vaultDeficit));

        return {
            avgFee,
            feeCV,
            timeUnderfundedPct,
            l1TrackingError: trackingError,
            fee95thPercentile,
            vaultBalanceStd,
            maxDeficit
        };
    }

    mean(arr) {
        return arr.reduce((sum, val) => sum + val, 0) / arr.length;
    }

    standardDeviation(arr) {
        const mean = this.mean(arr);
        const squaredDiffs = arr.map(val => Math.pow(val - mean, 2));
        return Math.sqrt(this.mean(squaredDiffs));
    }
}

// Revised optimization framework presets for optimal fee mechanism performance
const PRESETS = {
    'optimal': {
        mu: 0.0,
        nu: 0.27,
        H: 492,
        description: 'üéØ OPTIMAL: Revised framework validated parameters',
        objective: 'Multi-scenario consensus parameters for balanced performance',
        constraints: 'Scientifically optimized across all scenarios - 6-step aligned, consensus parameters',
        tradeoffs: 'Eliminates L1 correlation bias (Œº=0.0), consensus deficit correction (ŒΩ=0.27), extended horizon for stability',
        riskProfile: 'Validated across 320 solutions from 4 scenarios - robust multi-scenario performance',
        useCase: 'OPTIMAL STRATEGY: Œº=0.0, ŒΩ=0.27, H=492. Consensus parameters from comprehensive optimization.'
    },
    'balanced': {
        mu: 0.0,
        nu: 0.27,
        H: 492,
        description: '‚öñÔ∏è BALANCED: Multi-scenario consensus',
        objective: 'Robust performance across all market conditions',
        constraints: 'Consensus parameters from multi-scenario optimization',
        tradeoffs: 'Eliminates L1 correlation bias (Œº=0.0), consensus deficit correction, proven robustness',
        riskProfile: 'Multi-scenario validated - optimal balance across normal, spike, crash, and crisis conditions',
        useCase: 'BALANCED STRATEGY: Œº=0.0, ŒΩ=0.27, H=492. Same as optimal - consensus parameters.'
    },
    'crisis-resilient': {
        mu: 0.0,
        nu: 0.88,
        H: 120,
        description: '‚õëÔ∏è CRISIS-RESILIENT: Extreme volatility preparation',
        objective: 'Maximum safety scores in crisis scenarios',
        constraints: 'Highest safety scores in crisis scenarios with aggressive correction',
        tradeoffs: 'Eliminates L1 correlation bias (Œº=0.0), aggressive deficit correction (ŒΩ=0.88), shorter horizon for rapid response',
        riskProfile: 'Crisis-optimized - highest safety performance during extreme market volatility',
        useCase: 'CRISIS STRATEGY: Œº=0.0, ŒΩ=0.88, H=120. Aggressive correction for extreme volatility preparation.'
    }
};

// Export for use in main application
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        TaikoFeeSimulator,
        MetricsCalculator,
        EIP1559BaseFeeSimulator,
        PRESETS
    };
}

// Also export to global window object for browser usage
if (typeof window !== 'undefined') {
    window.TaikoFeeSimulator = TaikoFeeSimulator;
    window.MetricsCalculator = MetricsCalculator;
    window.EIP1559BaseFeeSimulator = EIP1559BaseFeeSimulator;
    window.PRESETS = PRESETS;
}


// === charts.js ===
// Chart.js configurations and utilities for Taiko Fee Explorer

class ChartManager {
    constructor() {
        this.charts = {};
        this.colors = {
            primary: '#4f46e5',
            secondary: '#10b981',
            accent: '#f59e0b',
            danger: '#ef4444',
            muted: '#6b7280'
        };
    }

    createFeeChart(canvasId, data, gasPerTx) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Use real historical timestamps when available, otherwise fall back to elapsed time
        const timeLabels = data.map((d, i) => {
            if (d.timestampLabel) {
                // Use real historical timestamp
                const date = new Date(d.timestampLabel);
                return date.toLocaleTimeString();
            } else {
                // Fall back to elapsed time for synthetic data
                const seconds = (typeof d.l2ElapsedSeconds === 'number') ? d.l2ElapsedSeconds : (i * 2);
                return `${(seconds / 3600).toFixed(2)}h`;
            }
        });
        // Convert from per-transaction ETH to per-gas gwei: (ETH * 1e9) / gasPerTx
        if (!gasPerTx || gasPerTx <= 0) {
            console.error(`üö® CRITICAL: gasPerTx parameter is ${gasPerTx} for main FeeChart`);
            console.error(`Expected: ~20,000 gas per transaction from simulator`);
        }
        const feeData = data.map((d, i) => {
            if (!gasPerTx || gasPerTx <= 0) {
                console.error(`‚ùå Data quality issue at index ${i}: gasPerTx is ${gasPerTx}`);
                return 0; // Make error visible
            }
            return (d.estimatedFee * 1e9) / gasPerTx;
        });

        this.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [{
                    label: 'Taiko Estimated Fee per Gas (gwei)',
                    data: feeData,
                    borderColor: this.colors.primary,
                    backgroundColor: this.colors.primary + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Taiko Estimated Fee per Gas Evolution Over Time',
                        font: { size: 14, weight: 600 },
                        color: '#2d3748',
                        padding: { bottom: 20 }
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 32, 44, 0.9)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: '#4299e1',
                        borderWidth: 1,
                        cornerRadius: 6,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                const value = context.raw;
                                return `Taiko Estimated Fee per Gas: ${value.toFixed(3)} gwei`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (hours)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Fee per Gas (gwei)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        },
                        type: 'linear'
                    }
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 6
                    }
                }
            }
        });
    }

    createVaultChart(canvasId, data, targetBalance = 100) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Use real historical timestamps when available, otherwise fall back to elapsed time
        const timeLabels = data.map((d, i) => {
            if (d.timestampLabel) {
                // Use real historical timestamp
                const date = new Date(d.timestampLabel);
                return date.toLocaleTimeString();
            } else {
                // Fall back to elapsed time for synthetic data
                const seconds = (typeof d.l2ElapsedSeconds === 'number') ? d.l2ElapsedSeconds : (i * 2);
                return `${(seconds / 3600).toFixed(2)}h`;
            }
        });
        const vaultData = data.map(d => d.vaultBalance);

        this.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Vault Balance (ETH)',
                        data: vaultData,
                        borderColor: this.colors.secondary,
                        backgroundColor: this.colors.secondary + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3
                    },
                    {
                        label: 'Target Balance',
                        data: new Array(data.length).fill(targetBalance),
                        borderColor: this.colors.muted,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Vault Balance Over Time',
                        font: { size: 14, weight: 600 },
                        color: '#2d3748',
                        padding: { bottom: 20 }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: { size: 11 },
                            color: '#4a5568'
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 32, 44, 0.9)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: '#4299e1',
                        borderWidth: 1,
                        cornerRadius: 6,
                        callbacks: {
                            title: function(context) {
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                const value = context.raw;
                                if (context.dataset.label === 'Vault Balance (ETH)') {
                                    return `${context.dataset.label}: ${value.toFixed(6)} ETH`;
                                } else {
                                    return `${context.dataset.label}: ${value.toFixed(1)} ETH`;
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (hours)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Balance (ETH)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    }
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 6
                    }
                }
            }
        });
    }

    createL1Chart(canvasId, data) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Use real historical timestamps when available, otherwise fall back to elapsed time
        const timeLabels = data.map((d, i) => {
            if (d.timestampLabel) {
                // Use real historical timestamp
                const date = new Date(d.timestampLabel);
                return date.toLocaleTimeString();
            } else {
                // Fall back to elapsed time for synthetic data
                const seconds = (typeof d.l1ElapsedSeconds === 'number') ? d.l1ElapsedSeconds : (i * 12);
                return `${(seconds / 3600).toFixed(2)}h`;
            }
        });
        const l1Data = data.map(d => d.l1Basefee / 1e9); // Convert to gwei

        this.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [{
                    label: 'L1 Basefee (gwei)',
                    data: l1Data,
                    borderColor: this.colors.muted,
                    backgroundColor: this.colors.muted + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'L1 Basefee Evolution',
                        font: { size: 14, weight: 600 },
                        color: '#2d3748',
                        padding: { bottom: 20 }
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 32, 44, 0.9)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: '#4299e1',
                        borderWidth: 1,
                        cornerRadius: 6,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                const value = context.raw;
                                return `Basefee: ${value.toFixed(2)} gwei`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (hours)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Basefee (gwei)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    }
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 6
                    }
                }
            }
        });
    }

    createCorrelationChart(canvasId, data, gasPerTx) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Create scatter plot data
        const scatterData = data.map(d => ({
            x: d.l1Basefee / 1e9, // gwei
            y: (d.estimatedFee * 1e9) / (gasPerTx || 200) // Convert ETH to per-gas gwei (corrected default)
        }));

        this.charts[canvasId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Taiko Estimated Fee per Gas vs L1 Basefee',
                    data: scatterData,
                    backgroundColor: this.colors.accent + '60',
                    borderColor: this.colors.accent,
                    borderWidth: 1,
                    pointRadius: 3,
                    pointHoverRadius: 5
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: true,
                    mode: 'point'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Taiko Estimated Fee per Gas vs L1 Basefee Correlation',
                        font: { size: 14, weight: 600 },
                        color: '#2d3748',
                        padding: { bottom: 20 }
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 32, 44, 0.9)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: '#4299e1',
                        borderWidth: 1,
                        cornerRadius: 6,
                        displayColors: false,
                        callbacks: {
                            title: function() {
                                return 'Data Point';
                            },
                            label: function(context) {
                                const point = context.raw;
                                return [
                                    `L1 Basefee: ${point.x.toFixed(2)} gwei`,
                                    `Taiko Estimated Fee per Gas: ${point.y.toFixed(3)} gwei`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'L1 Basefee (gwei)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Taiko Estimated Fee per Gas (gwei)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 11 }
                        },
                        type: 'linear'
                    }
                }
            }
        });
    }

    updateMetricCard(cardId, value, status) {
        const card = document.getElementById(cardId);
        const valueElement = card.querySelector('.metric-value');
        const statusElement = card.querySelector('.metric-status');

        // Format value based on metric type
        let formattedValue;
        if (cardId === 'avg-fee-card') {
            // Value is already in per-gas gwei, just format
            formattedValue = value.toFixed(3);
        } else if (cardId === 'fee-cv-card' || cardId === 'tracking-card') {
            formattedValue = value.toFixed(3);
        } else if (cardId === 'underfunded-card') {
            formattedValue = value.toFixed(1);
        } else {
            formattedValue = value.toString();
        }

        valueElement.textContent = formattedValue;

        // Update status
        statusElement.className = 'metric-status ' + status;
        statusElement.textContent = this.getStatusText(status);

        // Update card border based on status
        card.style.borderLeftColor = this.getStatusBorderColor(status);
        card.style.borderLeftWidth = '3px';
    }

    getStatusText(status) {
        switch(status) {
            case 'excellent': return '‚úÖ Excellent';
            case 'good': return 'üü° Good';
            case 'poor': return '‚ùå Poor';
            default: return '';
        }
    }

    getStatusBorderColor(status) {
        switch(status) {
            case 'excellent': return '#10b981';
            case 'good': return '#f59e0b';
            case 'poor': return '#ef4444';
            default: return '#e2e8f0';
        }
    }

    evaluateMetrics(metrics) {
        const evaluations = {};

        // Fee CV evaluation
        if (metrics.feeCV < 0.5) {
            evaluations.feeCV = 'excellent';
        } else if (metrics.feeCV < 1.0) {
            evaluations.feeCV = 'good';
        } else {
            evaluations.feeCV = 'poor';
        }

        // Time underfunded evaluation
        if (metrics.timeUnderfundedPct < 5) {
            evaluations.timeUnderfunded = 'excellent';
        } else if (metrics.timeUnderfundedPct < 15) {
            evaluations.timeUnderfunded = 'good';
        } else {
            evaluations.timeUnderfunded = 'poor';
        }

        // L1 tracking error evaluation
        if (metrics.l1TrackingError < 0.3) {
            evaluations.l1Tracking = 'excellent';
        } else if (metrics.l1TrackingError < 0.6) {
            evaluations.l1Tracking = 'good';
        } else {
            evaluations.l1Tracking = 'poor';
        }

        // Average fee evaluation (now in per-gas gwei)
        if (metrics.avgFee < 0.01) {
            evaluations.avgFee = 'excellent';
        } else if (metrics.avgFee < 0.1) {
            evaluations.avgFee = 'good';
        } else {
            evaluations.avgFee = 'poor';
        }

        return evaluations;
    }

    createL1EstimationChart(canvasId, data, gasPerTx) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        // Parameter validation - fail fast with no fallbacks
        if (!gasPerTx || gasPerTx <= 0) {
            console.error(`üö® CRITICAL: gasPerTx parameter is ${gasPerTx} for L1EstimationChart`);
            console.error(`Expected: ~20,000 gas per transaction from simulator`);
            console.error(`This will cause 100x+ scale error. Chart will show 0 values.`);
        }

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Use real historical timestamps when available, otherwise fall back to elapsed time
        const timeLabels = data.map((d, i) => {
            if (d.timestampLabel) {
                // Use real historical timestamp
                const date = new Date(d.timestampLabel);
                return date.toLocaleTimeString();
            } else {
                // Fall back to elapsed time for synthetic data
                const seconds = (typeof d.l1ElapsedSeconds === 'number') ? d.l1ElapsedSeconds : (i * 12);
                return `${(seconds / 3600).toFixed(2)}h`;
            }
        });
        const spotBasefeeData = data.map(d => d.l1Basefee / 1e9); // Convert wei to gwei
        const estimatedGasFeeData = data.map((d, i) => {
            const estimatedFee = d.estimatedFee || d.estimated_fee || 0;
            if (!gasPerTx || gasPerTx <= 0) {
                console.error(`‚ùå Data quality issue at index ${i}: gasPerTx is ${gasPerTx} (expected >0)`);
                console.error(`This will cause incorrect scaling. Expected range: 44-184 gwei for PEPE crisis`);
                return 0; // Make error visible in chart
            }
            return (estimatedFee * 1e9) / gasPerTx; // Convert ETH to gwei per gas
        });

        this.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'L1 Basefee per Gas (gwei)',
                        data: spotBasefeeData,
                        borderColor: this.colors.danger,
                        backgroundColor: this.colors.danger + '10',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    },
                    {
                        label: 'Estimated Gas Fee per Gas (gwei)',
                        data: estimatedGasFeeData,
                        borderColor: this.colors.primary,
                        backgroundColor: this.colors.primary + '20',
                        borderWidth: 2.5,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'L1 vs L2 Gas Pricing Comparison',
                        font: { size: 14, weight: 600 },
                        color: '#2d3748',
                        padding: { bottom: 20 }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: { size: 11 },
                            color: '#4a5568'
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 32, 44, 0.9)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: '#4299e1',
                        borderWidth: 1,
                        cornerRadius: 6,
                        displayColors: true,
                        callbacks: {
                            title: function(context) {
                                return `Time: ${context[0].label}`;
                            },
                            label: function(context) {
                                const value = context.raw;
                                return `${context.dataset.label}: ${value.toFixed(3)} gwei`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (hours)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 10 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Fee (gwei)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 10 },
                            callback: function(value) {
                                return value.toFixed(3);
                            }
                        }
                    }
                }
            }
        });

        return this.charts[canvasId];
    }

    createL2FeesChart(canvasId, data, params) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
        }

        // Use L2 timing for fee/deficit composition (Taiko steps = 2s)
        const timeLabels = data.map((d, i) => {
            const seconds = (typeof d.l2ElapsedSeconds === 'number') ? d.l2ElapsedSeconds : (i * 2);
            return `${(seconds / 3600).toFixed(2)}h`;
        });

        // Calculate L1 and deficit components
        const l1Components = data.map(d => {
            const l1Cost = d.estimatedL1Cost || 0;
            return params.mu * l1Cost; // L1 component: Œº √ó L1_cost
        });

        const deficitComponents = data.map(d => {
            const deficit = Math.max(0, d.vaultDeficit || 0);
            return params.nu * deficit / params.H; // Deficit component: ŒΩ √ó deficit/H
        });

        const totalFees = data.map(d => d.estimatedFee || 0);

        this.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Total L2 Estimated Fee',
                        data: totalFees,
                        borderColor: this.colors.primary,
                        backgroundColor: this.colors.primary + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    },
                    {
                        label: 'L1 Cost Component (Œº √ó L1_cost)',
                        data: l1Components,
                        borderColor: this.colors.success,
                        backgroundColor: this.colors.success + '20',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        borderDash: [5, 5]
                    },
                    {
                        label: 'Deficit Component (ŒΩ √ó deficit/H)',
                        data: deficitComponents,
                        borderColor: this.colors.warning,
                        backgroundColor: this.colors.warning + '20',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        borderDash: [10, 5]
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'L2 Fee Components Over Time',
                        color: '#2d3748',
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#4a5568',
                            font: { size: 11 },
                            usePointStyle: true,
                            padding: 15
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        titleColor: '#2d3748',
                        bodyColor: '#4a5568',
                        borderColor: '#e2e8f0',
                        borderWidth: 1,
                        cornerRadius: 6,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label;
                                const value = context.parsed.y;
                                if (value < 1e-6) {
                                    return `${label}: ${(value * 1e9).toFixed(6)} gwei`;
                                } else {
                                    return `${label}: ${value.toFixed(8)} ETH`;
                                }
                            },
                            afterLabel: function(context) {
                                if (context.datasetIndex === 0) { // Total fee
                                    const mu = params.mu;
                                    const nu = params.nu;
                                    return `Parameters: Œº=${mu}, ŒΩ=${nu}`;
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 10 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Fee (ETH)',
                            color: '#4a5568',
                            font: { size: 12 }
                        },
                        grid: {
                            color: '#e2e8f0'
                        },
                        ticks: {
                            color: '#718096',
                            font: { size: 10 },
                            callback: function(value) {
                                if (value < 1e-6) {
                                    return (value * 1e9).toFixed(3) + ' gwei';
                                } else {
                                    return value.toExponential(2) + ' ETH';
                                }
                            }
                        }
                    }
                }
            }
        });

        return this.charts[canvasId];
    }

    destroyAllCharts() {
        Object.values(this.charts).forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        this.charts = {};
    }
}

// Export for use in main application
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ChartManager };
} else {
    window.ChartManager = ChartManager;
}


// === pareto-visualizer.js ===
/**
 * 3D Pareto Frontier Visualization using Three.js
 *
 * Real-time visualization of multi-objective optimization results
 * showing Pareto optimal solutions in 3D space with:
 * - UX Score (X-axis, blue)
 * - Safety Score (Y-axis, red)
 * - Efficiency Score (Z-axis, green)
 */

class ParetoVisualizer {
    constructor(containerSelector) {
        this.container = document.querySelector(containerSelector);
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.solutionPoints = [];
        this.paretoPoints = [];
        this.animationId = null;

        // Interactive features
        this.raycaster = null;
        this.mouse = new THREE.Vector2();
        this.selectedPoint = null;
        this.hoveredPoint = null;
        this.intersectionObjects = [];

        // UI elements for interaction
        this.tooltipElement = null;
        this.detailPanel = null;

        // Callbacks
        this.onPointSelected = null;
        this.onPointHovered = null;

        // Animation controls
        this.animationSettings = {
            enabled: true,
            speed: 1.0,
            rotationEnabled: true,
            pulseEnabled: true,
            trailEnabled: false,
            autoRotateCamera: false,
            cameraSpeed: 0.5
        };

        this.animationTime = 0;
        this.pointTrails = new Map();

        this.init();
    }

    /**
     * Initialize the Three.js scene and visualization
     */
    init() {
        if (!this.container) {
            console.error('Container not found for Pareto visualization');
            return;
        }

        this.setupScene();
        this.setupCamera();
        this.setupRenderer();
        this.setupControls();
        this.setupAxes();
        this.setupLighting();
        this.setupInteractivity();
        this.setupUI();
        this.startAnimation();

        console.log('üéØ 3D Pareto visualization initialized');
    }

    /**
     * Setup the Three.js scene
     */
    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf8fafc);
        this.scene.fog = new THREE.Fog(0xf8fafc, 2, 15);
    }

    /**
     * Setup camera with optimal viewing angle
     */
    setupCamera() {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        this.camera.position.set(2.5, 2.5, 2.5);
        this.camera.lookAt(0.5, 0.5, 0.5);
    }

    /**
     * Setup WebGL renderer
     */
    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });

        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Clear container and add renderer
        this.container.innerHTML = '';
        this.container.appendChild(this.renderer.domElement);

        // Handle window resize
        window.addEventListener('resize', () => this.handleResize());
    }

    /**
     * Setup orbit controls for interactive viewing
     */
    setupControls() {
        if (typeof THREE.OrbitControls !== 'undefined') {
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.target.set(0.5, 0.5, 0.5);
            this.controls.minDistance = 1.5;
            this.controls.maxDistance = 8;
            this.controls.enableZoom = true;
            this.controls.enableRotate = true;
            this.controls.enablePan = true;
            this.controls.rotateSpeed = 1.0;
            this.controls.zoomSpeed = 1.2;
            this.controls.panSpeed = 0.8;
            this.controls.autoRotate = false;
            this.controls.autoRotateSpeed = 2.0;
        }
    }

    /**
     * Setup 3D axes with labels
     */
    setupAxes() {
        // Create axis lines
        const axisLength = 1.2;

        // UX Axis (X - Blue)
        const uxGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(axisLength, 0, 0)
        ]);
        const uxMaterial = new THREE.LineBasicMaterial({ color: 0x3182ce });
        const uxLine = new THREE.Line(uxGeometry, uxMaterial);
        this.scene.add(uxLine);

        // Safety Axis (Y - Red)
        const safetyGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, axisLength, 0)
        ]);
        const safetyMaterial = new THREE.LineBasicMaterial({ color: 0xe53e3e });
        const safetyLine = new THREE.Line(safetyGeometry, safetyMaterial);
        this.scene.add(safetyLine);

        // Efficiency Axis (Z - Green)
        const efficiencyGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, axisLength)
        ]);
        const efficiencyMaterial = new THREE.LineBasicMaterial({ color: 0x38a169 });
        const efficiencyLine = new THREE.Line(efficiencyGeometry, efficiencyMaterial);
        this.scene.add(efficiencyLine);

        // Add axis labels using CSS3DRenderer would be ideal, but for simplicity we'll use text sprites
        this.addAxisLabels();

        // Add grid lines
        this.addGridLines();
    }

    /**
     * Add text labels for axes
     */
    addAxisLabels() {
        const loader = new THREE.FontLoader();

        // Note: In production, you'd load a font file
        // For now, we'll create simple geometric text indicators

        // UX label (Blue arrow at end of X axis)
        const uxArrowGeometry = new THREE.ConeGeometry(0.02, 0.08, 8);
        const uxArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x3182ce });
        const uxArrow = new THREE.Mesh(uxArrowGeometry, uxArrowMaterial);
        uxArrow.position.set(1.25, 0, 0);
        uxArrow.rotateZ(-Math.PI / 2);
        this.scene.add(uxArrow);

        // Safety label (Red arrow at end of Y axis)
        const safetyArrowGeometry = new THREE.ConeGeometry(0.02, 0.08, 8);
        const safetyArrowMaterial = new THREE.MeshBasicMaterial({ color: 0xe53e3e });
        const safetyArrow = new THREE.Mesh(safetyArrowGeometry, safetyArrowMaterial);
        safetyArrow.position.set(0, 1.25, 0);
        this.scene.add(safetyArrow);

        // Efficiency label (Green arrow at end of Z axis)
        const efficiencyArrowGeometry = new THREE.ConeGeometry(0.02, 0.08, 8);
        const efficiencyArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x38a169 });
        const efficiencyArrow = new THREE.Mesh(efficiencyArrowGeometry, efficiencyArrowMaterial);
        efficiencyArrow.position.set(0, 0, 1.25);
        efficiencyArrow.rotateX(Math.PI / 2);
        this.scene.add(efficiencyArrow);
    }

    /**
     * Add grid lines for reference
     */
    addGridLines() {
        const gridMaterial = new THREE.LineBasicMaterial({
            color: 0xcccccc,
            opacity: 0.3,
            transparent: true
        });

        // Create grid on each plane
        for (let i = 0; i <= 10; i++) {
            const val = i / 10;

            // XY plane (Z=0)
            const xyGeometry1 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(val, 0, 0),
                new THREE.Vector3(val, 1, 0)
            ]);
            const xyLine1 = new THREE.Line(xyGeometry1, gridMaterial);
            this.scene.add(xyLine1);

            const xyGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, val, 0),
                new THREE.Vector3(1, val, 0)
            ]);
            const xyLine2 = new THREE.Line(xyGeometry2, gridMaterial);
            this.scene.add(xyLine2);

            // XZ plane (Y=0)
            const xzGeometry1 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(val, 0, 0),
                new THREE.Vector3(val, 0, 1)
            ]);
            const xzLine1 = new THREE.Line(xzGeometry1, gridMaterial);
            this.scene.add(xzLine1);

            const xzGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, val),
                new THREE.Vector3(1, 0, val)
            ]);
            const xzLine2 = new THREE.Line(xzGeometry2, gridMaterial);
            this.scene.add(xzLine2);

            // YZ plane (X=0)
            const yzGeometry1 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, val, 0),
                new THREE.Vector3(0, val, 1)
            ]);
            const yzLine1 = new THREE.Line(yzGeometry1, gridMaterial);
            this.scene.add(yzLine1);

            const yzGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, val),
                new THREE.Vector3(0, 1, val)
            ]);
            const yzLine2 = new THREE.Line(yzGeometry2, gridMaterial);
            this.scene.add(yzLine2);
        }
    }

    /**
     * Setup interactive features - raycasting, mouse events
     */
    setupInteractivity() {
        this.raycaster = new THREE.Raycaster();
        this.raycaster.params.Points.threshold = 0.05; // Increase sensitivity for point selection

        // Mouse event listeners
        this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));
        this.renderer.domElement.addEventListener('click', (event) => this.onMouseClick(event));
        this.renderer.domElement.addEventListener('mouseleave', () => this.onMouseLeave());

        // Prevent context menu on right click
        this.renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());
    }

    /**
     * Setup UI elements for interaction feedback
     */
    setupUI() {
        // Create tooltip element
        this.tooltipElement = document.createElement('div');
        this.tooltipElement.className = 'pareto-tooltip';
        this.tooltipElement.style.cssText = `
            position: absolute;
            background: rgba(45, 55, 72, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'SF Pro Text', system-ui, sans-serif;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            backdrop-filter: blur(8px);
        `;
        document.body.appendChild(this.tooltipElement);

        // Create detail panel in the visualization container
        this.detailPanel = document.createElement('div');
        this.detailPanel.className = 'pareto-detail-panel';
        this.detailPanel.style.cssText = `
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            width: 280px;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            backdrop-filter: blur(8px);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            z-index: 100;
        `;

        this.detailPanel.innerHTML = `
            <div class="detail-header">
                <h4 style="margin: 0 0 12px 0; color: #2d3748; font-weight: 600;">Solution Details</h4>
                <button class="close-detail" style="position: absolute; top: 12px; right: 12px; background: none; border: none; font-size: 16px; color: #6b7280; cursor: pointer;">√ó</button>
            </div>
            <div class="detail-content"></div>
        `;

        // Position detail panel relative to container
        this.container.style.position = 'relative';
        this.container.appendChild(this.detailPanel);

        // Close button functionality
        const closeBtn = this.detailPanel.querySelector('.close-detail');
        closeBtn.addEventListener('click', () => this.hideDetailPanel());
    }

    /**
     * Handle mouse movement for hover effects
     */
    onMouseMove(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update raycaster
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.intersectionObjects);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject !== this.hoveredPoint) {
                // Reset previous hovered point
                if (this.hoveredPoint) {
                    this.resetPointAppearance(this.hoveredPoint);
                }

                // Highlight new hovered point
                this.hoveredPoint = intersectedObject;
                this.highlightPoint(this.hoveredPoint, 'hover');
                this.showTooltip(event, this.hoveredPoint.userData);

                // Change cursor
                this.renderer.domElement.style.cursor = 'pointer';

                // Callback
                if (this.onPointHovered) {
                    this.onPointHovered(this.hoveredPoint.userData);
                }
            }

            // Update tooltip position
            this.updateTooltipPosition(event);

        } else {
            // No intersection
            if (this.hoveredPoint) {
                this.resetPointAppearance(this.hoveredPoint);
                this.hoveredPoint = null;
                this.hideTooltip();
                this.renderer.domElement.style.cursor = 'default';
            }
        }
    }

    /**
     * Handle mouse clicks for selection
     */
    onMouseClick(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.intersectionObjects);

        if (intersects.length > 0) {
            const clickedObject = intersects[0].object;

            // Reset previous selection
            if (this.selectedPoint && this.selectedPoint !== clickedObject) {
                this.resetPointAppearance(this.selectedPoint);
            }

            // Select new point
            this.selectedPoint = clickedObject;
            this.highlightPoint(this.selectedPoint, 'selected');
            this.showDetailPanel(this.selectedPoint.userData);

            // Callback
            if (this.onPointSelected) {
                this.onPointSelected(this.selectedPoint.userData);
            }
        } else {
            // Click on empty space - deselect
            if (this.selectedPoint) {
                this.resetPointAppearance(this.selectedPoint);
                this.selectedPoint = null;
                this.hideDetailPanel();
            }
        }
    }

    /**
     * Handle mouse leaving the canvas
     */
    onMouseLeave() {
        if (this.hoveredPoint) {
            this.resetPointAppearance(this.hoveredPoint);
            this.hoveredPoint = null;
        }
        this.hideTooltip();
        this.renderer.domElement.style.cursor = 'default';
    }

    /**
     * Highlight a point with different styles
     */
    highlightPoint(pointMesh, type = 'hover') {
        if (!pointMesh) return;

        const scale = type === 'selected' ? 2.2 : 1.5;
        const emissive = type === 'selected' ? 0x00ff88 : 0x888888; // Bright green for selected, light gray for hover

        // Scale animation
        const targetScale = scale;
        const currentScale = pointMesh.scale.x;

        if (Math.abs(currentScale - targetScale) > 0.1) {
            const animate = () => {
                const newScale = currentScale + (targetScale - currentScale) * 0.3;
                pointMesh.scale.set(newScale, newScale, newScale);

                if (Math.abs(newScale - targetScale) > 0.05) {
                    requestAnimationFrame(animate);
                } else {
                    pointMesh.scale.set(targetScale, targetScale, targetScale);
                }
            };
            animate();
        }

        // Material enhancement
        if (pointMesh.material) {
            pointMesh.material.emissive.setHex(emissive);
            pointMesh.material.needsUpdate = true;
        }
    }

    /**
     * Reset point appearance to default
     */
    resetPointAppearance(pointMesh) {
        if (!pointMesh) return;

        // Don't reset appearance of currently selected point to maintain persistent highlighting
        if (pointMesh === this.selectedPoint) return;

        const defaultScale = pointMesh.userData.isParetoOptimal ? 1.2 : 1.0;

        pointMesh.scale.set(defaultScale, defaultScale, defaultScale);

        if (pointMesh.material) {
            pointMesh.material.emissive.setHex(0x000000);
            pointMesh.material.needsUpdate = true;
        }
    }

    /**
     * Show tooltip with solution information
     */
    showTooltip(event, solutionData) {
        if (!this.tooltipElement || !solutionData) return;

        const tooltipContent = `
            <div style="font-weight: 600; margin-bottom: 8px; color: #ffffff;">
                ${solutionData.isParetoOptimal ? '‚≠ê Pareto Optimal' : 'üìç Solution'}
            </div>
            <div style="margin-bottom: 4px;">
                <strong>Parameters:</strong> Œº=${solutionData.mu.toFixed(3)}, ŒΩ=${solutionData.nu.toFixed(3)}, H=${solutionData.H}
            </div>
            <div style="margin-bottom: 4px;">
                <span style="color: #63b3ed;">UX:</span> ${solutionData.uxScore.toFixed(3)} |
                <span style="color: #f56565;">Safety:</span> ${solutionData.safetyScore.toFixed(3)} |
                <span style="color: #68d391;">Efficiency:</span> ${solutionData.efficiencyScore.toFixed(3)}
            </div>
            <div style="font-size: 11px; color: #cbd5e0; margin-top: 6px;">
                Click to view detailed analysis
            </div>
        `;

        this.tooltipElement.innerHTML = tooltipContent;
        this.updateTooltipPosition(event);
        this.tooltipElement.style.opacity = '1';
    }

    /**
     * Update tooltip position
     */
    updateTooltipPosition(event) {
        if (!this.tooltipElement) return;

        const offset = 15;
        this.tooltipElement.style.left = `${event.clientX + offset}px`;
        this.tooltipElement.style.top = `${event.clientY - this.tooltipElement.offsetHeight - offset}px`;
    }

    /**
     * Hide tooltip
     */
    hideTooltip() {
        if (this.tooltipElement) {
            this.tooltipElement.style.opacity = '0';
        }
    }

    /**
     * Show detailed information panel
     */
    showDetailPanel(solutionData) {
        if (!this.detailPanel || !solutionData) return;

        // Calculate overall score
        const overallScore = (solutionData.uxScore + solutionData.safetyScore + solutionData.efficiencyScore) / 3;

        const content = this.detailPanel.querySelector('.detail-content');
        content.innerHTML = `
            <div class="solution-summary" style="margin-bottom: 16px; padding: 12px; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #3182ce;">
                <div style="font-weight: 600; color: #1e40af; margin-bottom: 6px;">
                    ${solutionData.isParetoOptimal ? '‚≠ê Pareto Optimal Solution' : 'üìç Feasible Solution'}
                </div>
                <div style="font-size: 12px; color: #1e40af;">
                    Generation ${solutionData.generation || 'N/A'}
                </div>
            </div>

            <div class="overall-score" style="margin-bottom: 16px; padding: 12px; background: #f0fff4; border-radius: 8px; border-left: 4px solid #38a169; text-align: center;">
                <div style="font-size: 11px; color: #2f855a; font-weight: 500; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">
                    Overall Performance Score
                </div>
                <div style="font-size: 24px; font-weight: 700; color: #22543d;">
                    ${overallScore.toFixed(4)}
                </div>
                <div style="font-size: 11px; color: #2f855a; margin-top: 2px;">
                    Average of UX, Safety & Efficiency
                </div>
            </div>

            <div class="parameter-section" style="margin-bottom: 16px;">
                <h5 style="margin: 0 0 8px 0; color: #2d3748; font-size: 14px;">Fee Mechanism Parameters</h5>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                    <div style="background: #f8fafc; padding: 8px; border-radius: 6px;">
                        <strong>Œº (L1 Weight)</strong><br>
                        <span style="color: #3182ce; font-weight: 600;">${solutionData.mu.toFixed(4)}</span>
                    </div>
                    <div style="background: #f8fafc; padding: 8px; border-radius: 6px;">
                        <strong>ŒΩ (Deficit Weight)</strong><br>
                        <span style="color: #3182ce; font-weight: 600;">${solutionData.nu.toFixed(4)}</span>
                    </div>
                </div>
                <div style="background: #f8fafc; padding: 8px; border-radius: 6px; margin-top: 8px;">
                    <strong>H (Horizon)</strong><br>
                    <span style="color: #3182ce; font-weight: 600;">${solutionData.H} steps</span>
                    <span style="font-size: 11px; color: #6b7280;">(${(solutionData.H / 6).toFixed(1)} batches)</span>
                </div>
            </div>

            <div class="objectives-section" style="margin-bottom: 16px;">
                <h5 style="margin: 0 0 8px 0; color: #2d3748; font-size: 14px;">Objective Scores</h5>
                <div style="display: flex; flex-direction: column; gap: 6px; font-size: 13px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: #f0f9ff; border-radius: 4px;">
                        <span style="color: #3182ce; font-weight: 500;">üë• User Experience</span>
                        <span style="font-weight: 600;">${solutionData.uxScore.toFixed(4)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: #fef2f2; border-radius: 4px;">
                        <span style="color: #e53e3e; font-weight: 500;">üõ°Ô∏è Protocol Safety</span>
                        <span style="font-weight: 600;">${solutionData.safetyScore.toFixed(4)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: #f0fff4; border-radius: 4px;">
                        <span style="color: #38a169; font-weight: 500;">üí∞ Economic Efficiency</span>
                        <span style="font-weight: 600;">${solutionData.efficiencyScore.toFixed(4)}</span>
                    </div>
                </div>
            </div>

            <div class="actions-section">
                <button onclick="window.optimizationResearch?.exportSolution('${JSON.stringify(solutionData).replace(/"/g, '&quot;')}')"
                        style="width: 100%; padding: 8px 12px; background: #3182ce; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer; transition: background 0.2s;">
                    üìä Export Solution Data
                </button>
            </div>
        `;

        this.detailPanel.style.opacity = '1';
        this.detailPanel.style.transform = 'translateX(0)';
    }

    /**
     * Hide detailed information panel
     */
    hideDetailPanel() {
        if (this.detailPanel) {
            this.detailPanel.style.opacity = '0';
            this.detailPanel.style.transform = 'translateX(100%)';
        }
    }

    /**
     * Setup lighting for better visualization
     */
    setupLighting() {
        // Ambient light for overall illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        // Directional light for shadows and depth
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(2, 3, 1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        this.scene.add(directionalLight);
    }

    /**
     * Add a new solution point to the visualization
     */
    addSolution(solution) {
        const { uxScore, safetyScore, efficiencyScore, isParetoOptimal } = solution;

        // Create sphere geometry for the point
        const geometry = new THREE.SphereGeometry(isParetoOptimal ? 0.015 : 0.01, 16, 16);

        // Color based on Pareto optimality
        const color = isParetoOptimal ? 0xffd700 : 0x666666; // Gold for Pareto, gray for dominated
        const material = new THREE.MeshLambertMaterial({
            color: color,
            opacity: isParetoOptimal ? 1.0 : 0.6,
            transparent: true
        });

        const sphere = new THREE.Mesh(geometry, material);

        // Position in 3D space (normalize scores to [0,1] range)
        sphere.position.set(uxScore, safetyScore, efficiencyScore);

        // Add animation entrance effect
        sphere.scale.set(0, 0, 0);
        this.animatePointEntrance(sphere);

        // Store reference to solution data
        sphere.userData = solution;

        this.scene.add(sphere);

        // Register for interaction
        this.intersectionObjects.push(sphere);

        if (isParetoOptimal) {
            this.paretoPoints.push(sphere);
            this.updateParetoFrontSurface();
        } else {
            this.solutionPoints.push(sphere);
        }
    }

    /**
     * Animate point entrance with scaling effect
     */
    animatePointEntrance(sphere) {
        const startTime = Date.now();
        const duration = 500; // ms

        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Elastic scale animation
            const scale = progress * (1.1 - 0.1 * Math.cos(progress * Math.PI));
            sphere.scale.set(scale, scale, scale);

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                sphere.scale.set(1, 1, 1);
            }
        };

        animate();
    }

    /**
     * Update the Pareto front surface visualization
     */
    updateParetoFrontSurface() {
        // Remove existing surface if any
        const existingSurface = this.scene.getObjectByName('paretoSurface');
        if (existingSurface) {
            this.scene.remove(existingSurface);
        }

        if (this.paretoPoints.length < 3) return; // Need at least 3 points for a surface

        // Create a convex hull or simplified surface representation
        // For now, we'll connect Pareto points with lines to show the frontier
        this.createParetoLines();
    }

    /**
     * Create lines connecting Pareto optimal points
     */
    createParetoLines() {
        // Remove existing lines
        const existingLines = this.scene.getObjectByName('paretoLines');
        if (existingLines) {
            this.scene.remove(existingLines);
        }

        if (this.paretoPoints.length < 2) return;

        const group = new THREE.Group();
        group.name = 'paretoLines';

        // Create lines between nearby Pareto points
        for (let i = 0; i < this.paretoPoints.length; i++) {
            for (let j = i + 1; j < this.paretoPoints.length; j++) {
                const point1 = this.paretoPoints[i].position;
                const point2 = this.paretoPoints[j].position;

                // Only connect points that are reasonably close
                const distance = point1.distanceTo(point2);
                if (distance < 0.3) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
                    const material = new THREE.LineBasicMaterial({
                        color: 0xffd700,
                        opacity: 0.3,
                        transparent: true
                    });
                    const line = new THREE.Line(geometry, material);
                    group.add(line);
                }
            }
        }

        this.scene.add(group);
    }

    /**
     * Clear all solutions from the visualization
     */
    clear() {
        // Remove all solution points
        [...this.solutionPoints, ...this.paretoPoints].forEach(point => {
            this.scene.remove(point);
        });

        // Clear arrays
        this.solutionPoints = [];
        this.paretoPoints = [];
        this.intersectionObjects = [];

        // Reset interaction state
        this.selectedPoint = null;
        this.hoveredPoint = null;
        this.hideTooltip();
        this.hideDetailPanel();

        // Remove Pareto surface and lines
        const surface = this.scene.getObjectByName('paretoSurface');
        const lines = this.scene.getObjectByName('paretoLines');

        if (surface) this.scene.remove(surface);
        if (lines) this.scene.remove(lines);
    }

    /**
     * Handle window resize
     */
    handleResize() {
        if (!this.container || !this.camera || !this.renderer) return;

        const width = this.container.clientWidth;
        const height = this.container.clientHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    /**
     * Start the animation loop
     */
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate);

            if (!this.animationSettings.enabled) {
                this.renderer.render(this.scene, this.camera);
                return;
            }

            this.animationTime += 0.016 * this.animationSettings.speed; // 60fps base

            // Update controls
            if (this.controls) {
                this.controls.update();

                // Auto-rotate camera if enabled
                if (this.animationSettings.autoRotateCamera) {
                    this.controls.autoRotate = true;
                    this.controls.autoRotateSpeed = this.animationSettings.cameraSpeed;
                } else {
                    this.controls.autoRotate = false;
                }
            }

            // Animate Pareto points
            this.animatePoints();

            // Update trails if enabled
            if (this.animationSettings.trailEnabled) {
                this.updateTrails();
            }

            // Render the scene
            this.renderer.render(this.scene, this.camera);
        };

        animate();
    }

    /**
     * Animate individual points based on settings
     */
    animatePoints() {
        const rotationSpeed = 0.01 * this.animationSettings.speed;
        const pulseSpeed = 2.0 * this.animationSettings.speed;

        [...this.solutionPoints, ...this.paretoPoints].forEach((point, index) => {
            // Rotation animation
            if (this.animationSettings.rotationEnabled) {
                point.rotation.y += rotationSpeed;
                point.rotation.x += rotationSpeed * 0.5;
            }

            // Pulse animation
            if (this.animationSettings.pulseEnabled) {
                const pulsePhase = this.animationTime * pulseSpeed + index * 0.5;
                const pulseScale = 1.0 + 0.1 * Math.sin(pulsePhase);
                point.scale.setScalar(pulseScale);

                // Pulse opacity for non-Pareto points
                if (this.solutionPoints.includes(point)) {
                    const material = point.material;
                    if (material && material.opacity !== undefined) {
                        material.opacity = 0.7 + 0.2 * Math.sin(pulsePhase);
                    }
                }
            }
        });
    }

    /**
     * Update trail effects for moving points
     */
    updateTrails() {
        // Implementation for particle trails - can be extended later
        // This would create trailing effects behind moving points
    }

    /**
     * Stop the animation loop
     */
    stopAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    /**
     * Destroy the visualizer and clean up resources
     */
    destroy() {
        this.stopAnimation();

        // Clean up interaction elements
        if (this.tooltipElement) {
            document.body.removeChild(this.tooltipElement);
            this.tooltipElement = null;
        }

        if (this.detailPanel) {
            this.container.removeChild(this.detailPanel);
            this.detailPanel = null;
        }

        // Remove event listeners
        if (this.renderer && this.renderer.domElement) {
            this.renderer.domElement.removeEventListener('mousemove', this.onMouseMove);
            this.renderer.domElement.removeEventListener('click', this.onMouseClick);
            this.renderer.domElement.removeEventListener('mouseleave', this.onMouseLeave);
        }

        if (this.renderer) {
            this.renderer.dispose();
        }

        if (this.controls) {
            this.controls.dispose();
        }

        // Clear the container
        if (this.container) {
            this.container.innerHTML = '';
        }
    }

    /**
     * Export the current view as an image
     */
    exportImage(filename = 'pareto-frontier') {
        if (!this.renderer) return;

        // Render at high resolution
        const originalSize = new THREE.Vector2();
        this.renderer.getSize(originalSize);

        const exportWidth = 1920;
        const exportHeight = 1080;

        this.renderer.setSize(exportWidth, exportHeight);
        this.camera.aspect = exportWidth / exportHeight;
        this.camera.updateProjectionMatrix();

        this.renderer.render(this.scene, this.camera);

        // Create download link
        const canvas = this.renderer.domElement;
        canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}-${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Restore original size
            this.renderer.setSize(originalSize.x, originalSize.y);
            this.camera.aspect = originalSize.x / originalSize.y;
            this.camera.updateProjectionMatrix();
        });
    }

    /**
     * Get statistics about the current visualization
     */
    getStats() {
        return {
            totalSolutions: this.solutionPoints.length + this.paretoPoints.length,
            paretoOptimal: this.paretoPoints.length,
            dominated: this.solutionPoints.length,
            paretoRatio: this.paretoPoints.length / (this.solutionPoints.length + this.paretoPoints.length)
        };
    }

    /**
     * Update animation settings
     */
    setAnimationSettings(settings) {
        this.animationSettings = { ...this.animationSettings, ...settings };
    }

    /**
     * Get current animation settings
     */
    getAnimationSettings() {
        return { ...this.animationSettings };
    }

    /**
     * Toggle specific animation features
     */
    toggleAnimation(feature, enabled) {
        if (feature in this.animationSettings) {
            this.animationSettings[feature] = enabled;
        }
    }

    /**
     * Set animation speed multiplier
     */
    setAnimationSpeed(speed) {
        this.animationSettings.speed = Math.max(0.1, Math.min(5.0, speed));
    }

    /**
     * Reset camera position with smooth animation
     */
    resetCameraPosition(animated = true) {
        if (!this.camera || !this.controls) return;

        const targetPosition = { x: 2.5, y: 2.5, z: 2.5 };
        const targetTarget = { x: 0.5, y: 0.5, z: 0.5 };

        if (animated) {
            // Smooth animation to reset position
            const startPosition = this.camera.position.clone();
            const startTarget = this.controls.target.clone();
            const duration = 1000; // 1 second
            const startTime = Date.now();

            const animateReset = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease-out cubic

                // Interpolate camera position
                this.camera.position.lerpVectors(startPosition,
                    new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z),
                    easeProgress);

                // Interpolate target
                this.controls.target.lerpVectors(startTarget,
                    new THREE.Vector3(targetTarget.x, targetTarget.y, targetTarget.z),
                    easeProgress);

                this.controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateReset);
                }
            };

            animateReset();
        } else {
            // Immediate reset
            this.camera.position.set(targetPosition.x, targetPosition.y, targetPosition.z);
            this.controls.target.set(targetTarget.x, targetTarget.y, targetTarget.z);
            this.controls.update();
        }
    }

    /**
     * Focus camera on a specific region with animation
     */
    focusOnRegion(center, radius = 1, duration = 1000) {
        if (!this.camera || !this.controls) return;

        const startPosition = this.camera.position.clone();
        const startTarget = this.controls.target.clone();

        const targetPosition = new THREE.Vector3()
            .copy(center)
            .add(new THREE.Vector3(radius, radius, radius));

        const targetTarget = center.clone();

        const startTime = Date.now();

        const animateFocus = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease-out cubic

            this.camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
            this.controls.target.lerpVectors(startTarget, targetTarget, easeProgress);
            this.controls.update();

            if (progress < 1) {
                requestAnimationFrame(animateFocus);
            }
        };

        animateFocus();
    }

    /**
     * Focus camera on selected point
     */
    focusOnPoint(solution) {
        if (!this.camera || !this.controls) return;

        const point = this.intersectionObjects.find(obj =>
            obj.userData.id === solution.id ||
            (obj.userData.mu === solution.mu && obj.userData.nu === solution.nu && obj.userData.H === solution.H)
        );

        if (point) {
            // Animate camera to focus on point
            const targetPosition = point.position.clone();
            targetPosition.multiplyScalar(1.5); // Move camera back a bit

            this.controls.target.copy(point.position);
            this.camera.position.copy(targetPosition);
            this.controls.update();

            // Highlight the point
            if (this.selectedPoint && this.selectedPoint !== point) {
                this.resetPointAppearance(this.selectedPoint);
            }
            this.selectedPoint = point;
            this.highlightPoint(point, 'selected');
            this.showDetailPanel(point.userData);
        }
    }

    /**
     * Filter visible solutions based on criteria
     */
    filterSolutions(criteria) {
        [...this.solutionPoints, ...this.paretoPoints].forEach(point => {
            const solution = point.userData;
            let visible = true;

            if (criteria.paretoOnly && !solution.isParetoOptimal) {
                visible = false;
            }

            if (criteria.minUX !== undefined && solution.uxScore < criteria.minUX) {
                visible = false;
            }

            if (criteria.minSafety !== undefined && solution.safetyScore < criteria.minSafety) {
                visible = false;
            }

            if (criteria.minEfficiency !== undefined && solution.efficiencyScore < criteria.minEfficiency) {
                visible = false;
            }

            point.visible = visible;
        });
    }

    /**
     * Reset all filters
     */
    resetFilters() {
        [...this.solutionPoints, ...this.paretoPoints].forEach(point => {
            point.visible = true;
        });
    }

    /**
     * Set callback functions for interaction events
     */
    setCallbacks({ onPointSelected, onPointHovered }) {
        this.onPointSelected = onPointSelected;
        this.onPointHovered = onPointHovered;
    }

    /**
     * Programmatically select a point by solution parameters
     */
    selectPointBySolution(solution) {
        // Extract solution parameters with fallback
        const targetMu = solution.parameters?.mu || solution.mu;
        const targetNu = solution.parameters?.nu || solution.nu;
        const targetH = solution.parameters?.horizon || solution.H;

        if (targetMu === undefined || targetNu === undefined || targetH === undefined) {
            console.warn('Cannot select point: missing solution parameters', solution);
            return false;
        }

        // Find matching point in 3D visualization
        const allPoints = [...this.solutionPoints, ...this.paretoPoints];
        const matchingPoint = allPoints.find(point => {
            const pointSolution = point.userData;
            const pointMu = pointSolution.parameters?.mu || pointSolution.mu;
            const pointNu = pointSolution.parameters?.nu || pointSolution.nu;
            const pointH = pointSolution.parameters?.horizon || pointSolution.H;

            // Use small epsilon for floating point comparison
            const epsilon = 0.0001;
            return Math.abs(pointMu - targetMu) < epsilon &&
                   Math.abs(pointNu - targetNu) < epsilon &&
                   pointH === targetH;
        });

        if (matchingPoint) {
            // Reset previous selection
            if (this.selectedPoint && this.selectedPoint !== matchingPoint) {
                this.resetPointAppearance(this.selectedPoint);
            }

            // Select the new point
            this.selectedPoint = matchingPoint;
            this.highlightPoint(matchingPoint, 'selected');

            return true;
        } else {
            console.warn('No matching 3D point found for solution:', {
                mu: targetMu,
                nu: targetNu,
                H: targetH,
                availablePoints: allPoints.length
            });
            return false;
        }
    }

    /**
     * Get all solutions data
     */
    getAllSolutions() {
        return [...this.solutionPoints, ...this.paretoPoints].map(point => point.userData);
    }

    /**
     * Get only Pareto optimal solutions
     */
    getParetoSolutions() {
        return this.paretoPoints.map(point => point.userData);
    }
}

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ParetoVisualizer;
}

// Make available globally
window.ParetoVisualizer = ParetoVisualizer;

// === nsga-ii-web.js ===
/**
 * Web-Adapted NSGA-II Multi-Objective Optimization Engine
 *
 * Browser-compatible implementation of NSGA-II (Non-dominated Sorting Genetic Algorithm II)
 * for optimizing Taiko fee mechanism parameters across three objectives:
 * - User Experience (UX)
 * - Protocol Safety
 * - Economic Efficiency
 *
 * Features:
 * - Real-time optimization with progress callbacks
 * - Web Worker support for non-blocking execution
 * - Configurable population size and generation limits
 * - Pareto frontier tracking and dominance relationships
 * - Parameter constraint handling (6-step alignment, bounds checking)
 */

class Individual {
    constructor(mu = 0, nu = 0.1, H = 36) {
        this.mu = mu;           // L1 weight parameter [0.0, 1.0]
        this.nu = nu;           // Deficit weight parameter [0.02, 1.0]
        this.H = H;             // Horizon parameter (6-step aligned)

        // Objective values (higher is better, will be negated for minimization)
        this.uxScore = null;
        this.safetyScore = null;
        this.efficiencyScore = null;

        // NSGA-II specific attributes
        this.dominationCount = 0;       // Number of solutions dominating this one
        this.dominatedSolutions = [];   // Solutions dominated by this one
        this.rank = null;               // Non-domination rank
        this.crowdingDistance = 0;      // Crowding distance for diversity

        // Constraint handling
        this.constraintViolations = 0;
        this.isFeasible = true;

        // Metadata
        this.generation = 0;
        this.evaluationTime = 0;
    }

    /**
     * Create a copy of this individual
     */
    clone() {
        const copy = new Individual(this.mu, this.nu, this.H);
        copy.uxScore = this.uxScore;
        copy.safetyScore = this.safetyScore;
        copy.efficiencyScore = this.efficiencyScore;
        copy.constraintViolations = this.constraintViolations;
        copy.isFeasible = this.isFeasible;
        return copy;
    }

    /**
     * Check if this individual dominates another
     */
    dominates(other) {
        if (!this.isFeasible && other.isFeasible) return false;
        if (this.isFeasible && !other.isFeasible) return true;

        let atLeastOneBetter = false;
        let anyWorse = false;

        // Compare all objectives (higher is better)
        const objectives = ['uxScore', 'safetyScore', 'efficiencyScore'];

        for (const obj of objectives) {
            if (this[obj] > other[obj]) {
                atLeastOneBetter = true;
            } else if (this[obj] < other[obj]) {
                anyWorse = true;
                break;
            }
        }

        return atLeastOneBetter && !anyWorse;
    }

    /**
     * Get parameter values as array for genetic operations
     */
    getParameters() {
        return [this.mu, this.nu, this.H];
    }

    /**
     * Set parameters from array
     */
    setParameters(params) {
        this.mu = params[0];
        this.nu = params[1];
        this.H = params[2];
    }
}

class ParameterBounds {
    constructor() {
        this.muBounds = [0.0, 1.0];
        this.nuBounds = [0.02, 1.0];
        this.HBounds = [6, 576];

        // Pre-computed 6-step aligned H values for efficiency
        this.validHValues = [];
        for (let h = this.HBounds[0]; h <= this.HBounds[1]; h += 6) {
            this.validHValues.push(h);
        }
    }

    /**
     * Generate random individual within bounds
     */
    generateRandomIndividual() {
        const mu = Math.random() * (this.muBounds[1] - this.muBounds[0]) + this.muBounds[0];
        const nu = Math.random() * (this.nuBounds[1] - this.nuBounds[0]) + this.nuBounds[0];
        const H = this.validHValues[Math.floor(Math.random() * this.validHValues.length)];

        return new Individual(mu, nu, H);
    }

    /**
     * Repair individual to satisfy constraints
     */
    repairIndividual(individual) {
        // Clamp mu and nu to bounds
        individual.mu = Math.max(this.muBounds[0], Math.min(this.muBounds[1], individual.mu));
        individual.nu = Math.max(this.nuBounds[0], Math.min(this.nuBounds[1], individual.nu));

        // Find closest valid H value
        const targetH = Math.max(this.HBounds[0], Math.min(this.HBounds[1], individual.H));
        individual.H = this.validHValues.reduce((prev, curr) =>
            Math.abs(curr - targetH) < Math.abs(prev - targetH) ? curr : prev
        );

        return individual;
    }
}

class GeneticOperators {
    constructor(crossoverProbability = 0.9, mutationProbability = 0.1) {
        this.crossoverProbability = crossoverProbability;
        this.mutationProbability = mutationProbability;
        this.bounds = new ParameterBounds();
    }

    /**
     * Simulated Binary Crossover (SBX)
     */
    crossover(parent1, parent2) {
        if (Math.random() > this.crossoverProbability) {
            return [parent1.clone(), parent2.clone()];
        }

        const eta = 20; // Distribution index
        const offspring1 = parent1.clone();
        const offspring2 = parent2.clone();

        const params1 = parent1.getParameters();
        const params2 = parent2.getParameters();

        for (let i = 0; i < 2; i++) { // Only crossover mu and nu (not H)
            if (Math.random() <= 0.5) {
                const y1 = params1[i];
                const y2 = params2[i];

                if (Math.abs(y1 - y2) > 1e-14) {
                    const lb = i === 0 ? this.bounds.muBounds[0] : this.bounds.nuBounds[0];
                    const ub = i === 0 ? this.bounds.muBounds[1] : this.bounds.nuBounds[1];

                    const rand = Math.random();
                    const beta = this.getBeta(rand, eta, y1, y2, lb, ub);

                    const c1 = 0.5 * (y1 + y2 - beta * Math.abs(y2 - y1));
                    const c2 = 0.5 * (y1 + y2 + beta * Math.abs(y2 - y1));

                    params1[i] = Math.max(lb, Math.min(ub, c1));
                    params2[i] = Math.max(lb, Math.min(ub, c2));
                }
            }
        }

        // Handle H crossover (discrete)
        if (Math.random() <= 0.5) {
            [params1[2], params2[2]] = [params2[2], params1[2]];
        }

        offspring1.setParameters(params1);
        offspring2.setParameters(params2);

        return [
            this.bounds.repairIndividual(offspring1),
            this.bounds.repairIndividual(offspring2)
        ];
    }

    /**
     * Calculate beta for SBX crossover
     */
    getBeta(rand, eta, y1, y2, lb, ub) {
        // Clamp random draw to avoid infinities/NaNs when rand is extremely close to 0 or 1
        const u = Math.min(Math.max(rand, 1e-12), 1 - 1e-12);

        // Standard SBX beta computation (Deb et al.)
        if (u <= 0.5) {
            return Math.pow(2.0 * u, 1.0 / (eta + 1.0));
        }

        return Math.pow(1.0 / (2.0 * (1.0 - u)), 1.0 / (eta + 1.0));
    }

    /**
     * Polynomial mutation
     */
    mutate(individual) {
        const mutated = individual.clone();
        const eta = 20; // Distribution index
        const params = mutated.getParameters();

        for (let i = 0; i < 2; i++) { // Only mutate mu and nu
            if (Math.random() <= this.mutationProbability) {
                const y = params[i];
                const lb = i === 0 ? this.bounds.muBounds[0] : this.bounds.nuBounds[0];
                const ub = i === 0 ? this.bounds.muBounds[1] : this.bounds.nuBounds[1];

                const delta1 = (y - lb) / (ub - lb);
                const delta2 = (ub - y) / (ub - lb);

                const rand = Math.random();
                let mutPow, deltaq;

                if (rand <= 0.5) {
                    const xy = 1.0 - delta1;
                    const val = 2.0 * rand + (1.0 - 2.0 * rand) * Math.pow(xy, eta + 1.0);
                    deltaq = Math.pow(val, 1.0 / (eta + 1.0)) - 1.0;
                } else {
                    const xy = 1.0 - delta2;
                    const val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * Math.pow(xy, eta + 1.0);
                    deltaq = 1.0 - Math.pow(val, 1.0 / (eta + 1.0));
                }

                params[i] = y + deltaq * (ub - lb);
                params[i] = Math.max(lb, Math.min(ub, params[i]));
            }
        }

        // Mutate H (discrete)
        if (Math.random() <= this.mutationProbability) {
            const currentIndex = this.bounds.validHValues.indexOf(params[2]);
            const maxShift = Math.min(5, this.bounds.validHValues.length - 1);
            const shift = Math.floor(Math.random() * (2 * maxShift + 1)) - maxShift;
            const newIndex = Math.max(0, Math.min(this.bounds.validHValues.length - 1, currentIndex + shift));
            params[2] = this.bounds.validHValues[newIndex];
        }

        mutated.setParameters(params);
        return this.bounds.repairIndividual(mutated);
    }

    /**
     * Tournament selection
     */
    tournamentSelection(population, tournamentSize = 3) {
        const tournament = [];

        for (let i = 0; i < tournamentSize; i++) {
            tournament.push(population[Math.floor(Math.random() * population.length)]);
        }

        // Select best individual from tournament based on rank and crowding distance
        tournament.sort((a, b) => {
            if (a.rank !== b.rank) {
                return a.rank - b.rank; // Lower rank is better
            }
            return b.crowdingDistance - a.crowdingDistance; // Higher crowding distance is better
        });

        return tournament[0].clone();
    }
}

class TaikoFeeEvaluator {
    constructor(weights, simulationParams) {
        this.weights = weights || this.getDefaultWeights();
        this.simulationParams = simulationParams || this.getDefaultSimulationParams();
    }

    getDefaultWeights() {
        return {
            w1_fee_affordability: 0.40,
            w2_fee_stability: 0.30,
            w3_fee_predictability_1h: 0.20,
            w4_fee_predictability_6h: 0.10,
            w5_insolvency_protection: 0.40,
            w6_deficit_duration: 0.30,
            w7_vault_stress: 0.20,
            w8_continuous_underfunding: 0.10,
            w9_vault_utilization: 0.40,
            w10_deficit_correction: 0.30,
            w11_capital_efficiency: 0.30
        };
    }

    getDefaultSimulationParams() {
        return {
            target_balance: 1000.0,
            base_demand: 100,
            fee_elasticity: 0.2,
            gas_per_batch: 200000,
            txs_per_batch: 100,
            batch_frequency: 0.1,
            time_step_seconds: 2,
            total_steps: 500
        };
    }

    /**
     * Evaluate an individual's fitness across all objectives
     */
    async evaluate(individual) {
        const startTime = Date.now();

        try {
            // Run simulation with individual's parameters
            const simulationResults = await this.runSimulation(individual);

            // Calculate composite scores
            const scores = this.calculateCompositeScores(simulationResults);

            // Update individual with scores
            individual.uxScore = scores.uxScore;
            individual.safetyScore = scores.safetyScore;
            individual.efficiencyScore = scores.efficiencyScore;

            // Check feasibility
            individual.isFeasible = this.checkFeasibility(simulationResults, individual);
            individual.constraintViolations = this.countConstraintViolations(simulationResults, individual);

            individual.evaluationTime = Date.now() - startTime;

        } catch (error) {
            console.warn(`Evaluation failed for (Œº=${individual.mu}, ŒΩ=${individual.nu}, H=${individual.H}):`, error);

            // Assign worst possible scores
            individual.uxScore = 0;
            individual.safetyScore = 0;
            individual.efficiencyScore = 0;
            individual.isFeasible = false;
            individual.constraintViolations = 999;
            individual.evaluationTime = Date.now() - startTime;
        }

        return individual;
    }

    /**
     * Run fee mechanism simulation (placeholder - would integrate with actual simulator)
     */
    async runSimulation(individual) {
        // Use real Taiko fee mechanism simulation with multi-scenario evaluation
        try {
            // Check if required components are available
            if (!window.historicalDataLoader || !window.historicalDataLoader.loaded) {
                throw new Error('Historical data not loaded. Make sure all components are initialized.');
            }

            // Create multi-scenario evaluator if not already available
            if (!this.multiScenarioEvaluator) {
                const metricsCalculator = new window.EnhancedMetricsCalculator();
                this.multiScenarioEvaluator = new window.MultiScenarioEvaluator(
                    window.historicalDataLoader,
                    metricsCalculator
                );
            }

            // Evaluate parameter set across all historical scenarios
            const evaluationResult = await this.multiScenarioEvaluator.evaluateParameterSet({
                mu: individual.mu,
                nu: individual.nu,
                H: individual.H
            });

            // Return aggregated metrics for optimization
            return {
                ux_score: evaluationResult.aggregated_metrics.robust_ux_score,
                safety_score: evaluationResult.aggregated_metrics.robust_safety_score,
                overall_score: evaluationResult.aggregated_metrics.robust_overall_score,
                insolvency_probability: evaluationResult.aggregated_metrics.insolvency_probability_mean,
                fee_affordability: evaluationResult.aggregated_metrics.fee_affordability_score_mean,
                fee_stability: evaluationResult.aggregated_metrics.fee_stability_score_mean,
                deficit_weighted_duration: evaluationResult.aggregated_metrics.deficit_weighted_duration_mean,
                evaluation_details: evaluationResult  // Store full results for debugging
            };

        } catch (error) {
            console.warn('Real simulation failed, falling back to simplified calculation:', error);

            // Fallback to simplified calculation if real simulation fails
            return this.runSimplifiedSimulation(individual);
        }
    }

    /**
     * Fallback simplified simulation for when real simulation isn't available
     */
    runSimplifiedSimulation(individual) {
        // Simplified scoring based on known optimal parameter relationships
        const optimalMu = 0.0;
        const optimalNu = 0.1;
        const optimalH = 36;

        // Calculate distance from optimal parameters (normalized)
        const muDistance = Math.abs(individual.mu - optimalMu) / 1.0;
        const nuDistance = Math.abs(individual.nu - optimalNu) / 0.9;
        const hDistance = Math.abs(individual.H - optimalH) / 576;

        // Combined distance score (lower is better)
        const distanceFromOptimal = Math.sqrt(muDistance*muDistance + nuDistance*nuDistance + hDistance*hDistance);

        // Convert to scores (higher is better)
        const baseScore = Math.max(0, 1 - distanceFromOptimal);

        return {
            ux_score: baseScore + Math.random() * 0.1 - 0.05,  // Add small noise
            safety_score: baseScore + Math.random() * 0.1 - 0.05,
            overall_score: baseScore + Math.random() * 0.1 - 0.05,
            insolvency_probability: distanceFromOptimal * 0.2 + Math.random() * 0.1,
            fee_affordability: baseScore + Math.random() * 0.1 - 0.05,
            fee_stability: baseScore + Math.random() * 0.1 - 0.05,
            deficit_weighted_duration: distanceFromOptimal * 100 + Math.random() * 10,
            is_fallback: true
        };
    }

    /**
     * Calculate composite scores from simulation results
     */
    calculateCompositeScores(results) {
        const w = this.weights;

        // Use either real metrics or fallback calculations
        // All metrics normalized to [0, 1] where 1 is best

        if (results.is_fallback) {
            // Use simplified calculations for fallback mode
            const feeAffordability = results.fee_affordability;
            const feeStability = results.fee_stability;
            const feePredictability1h = feeStability * 0.9;  // Approximate
            const feePredictability6h = feeStability * 0.95;

            const insolvencyProtection = Math.max(0, 1 - results.insolvency_probability);
            const deficitDuration = Math.max(0, 1 - results.deficit_weighted_duration / 100);
            const vaultStress = Math.max(0, 1 - results.insolvency_probability * 0.5);
            const continuousUnderfunding = vaultStress;

            const vaultUtilization = Math.max(0.5, 1 - results.insolvency_probability);
            const deficitCorrection = deficitDuration;
            const capitalEfficiency = vaultUtilization;

            results.individual_metrics = {
                feeAffordability, feeStability, feePredictability1h, feePredictability6h,
                insolvencyProtection, deficitDuration, vaultStress, continuousUnderfunding,
                vaultUtilization, deficitCorrection, capitalEfficiency
            };
        } else {
            // Use real calculated metrics directly
            const feeAffordability = Math.max(0, results.fee_affordability || 0);
            const feeStability = Math.max(0, results.fee_stability || 0);
            const feePredictability1h = feeStability * 0.9;  // Simplified for now
            const feePredictability6h = feeStability * 0.95;

            const insolvencyProtection = Math.max(0, 1 - (results.insolvency_probability || 0));
            const deficitDuration = Math.max(0, 1 - Math.min(1, (results.deficit_weighted_duration || 0) / 100));
            const vaultStress = insolvencyProtection;
            const continuousUnderfunding = vaultStress;

            const vaultUtilization = Math.max(0.5, insolvencyProtection);
            const deficitCorrection = deficitDuration;
            const capitalEfficiency = vaultUtilization;

            results.individual_metrics = {
                feeAffordability, feeStability, feePredictability1h, feePredictability6h,
                insolvencyProtection, deficitDuration, vaultStress, continuousUnderfunding,
                vaultUtilization, deficitCorrection, capitalEfficiency
            };
        }

        // Extract individual metrics for score calculation
        const {
            feeAffordability, feeStability, feePredictability1h, feePredictability6h,
            insolvencyProtection, deficitDuration, vaultStress, continuousUnderfunding,
            vaultUtilization, deficitCorrection, capitalEfficiency
        } = results.individual_metrics;

        // Calculate composite scores using the research-validated weighting
        const uxScore = (
            w.w1_fee_affordability * feeAffordability +
            w.w2_fee_stability * feeStability +
            w.w3_fee_predictability_1h * feePredictability1h +
            w.w4_fee_predictability_6h * feePredictability6h
        );

        const safetyScore = (
            w.w5_insolvency_protection * insolvencyProtection +
            w.w6_deficit_duration * deficitDuration +
            w.w7_vault_stress * vaultStress +
            w.w8_continuous_underfunding * continuousUnderfunding
        );

        const efficiencyScore = (
            w.w9_vault_utilization * vaultUtilization +
            w.w10_deficit_correction * deficitCorrection +
            w.w11_capital_efficiency * capitalEfficiency
        );

        // If real simulation was used, prefer those composite scores
        const finalUxScore = results.ux_score !== undefined ? results.ux_score : uxScore;
        const finalSafetyScore = results.safety_score !== undefined ? results.safety_score : safetyScore;
        const finalOverallScore = results.overall_score !== undefined ? results.overall_score :
            (0.5 * finalUxScore + 0.35 * finalSafetyScore + 0.15 * efficiencyScore);

        return {
            uxScore: finalUxScore,
            safetyScore: finalSafetyScore,
            efficiencyScore: efficiencyScore,
            overallScore: finalOverallScore
        };
    }

    /**
     * Check if solution satisfies constraints
     */
    checkFeasibility(results, individual) {
        // 6-step alignment constraint
        if (individual.H % 6 !== 0) return false;

        // Basic safety constraints
        if (results.insolvency_risk > 0.8) return false;
        if (results.deficit_duration > 150) return false;

        return true;
    }

    /**
     * Count constraint violations
     */
    countConstraintViolations(results, individual) {
        let violations = 0;

        if (individual.H % 6 !== 0) violations++;
        if (results.insolvency_risk > 0.8) violations++;
        if (results.deficit_duration > 150) violations++;
        if (results.vault_utilization < 0.1) violations++;

        return violations;
    }
}

class NSGAII {
    constructor(options = {}) {
        this.populationSize = options.populationSize || 50;
        this.maxGenerations = options.maxGenerations || 100;
        this.crossoverRate = options.crossoverRate || 0.9;
        this.mutationRate = options.mutationRate || 0.1;
        this.weights = options.weights || {};

        this.bounds = new ParameterBounds();
        this.operators = new GeneticOperators(this.crossoverRate, this.mutationRate);
        this.evaluator = new TaikoFeeEvaluator(this.weights);

        this.population = [];
        this.generation = 0;
        this.isRunning = false;

        // Callbacks
        this.onProgress = options.onProgress || (() => {});
        this.onSolution = options.onSolution || (() => {});
        this.onComplete = options.onComplete || (() => {});
    }

    /**
     * Initialize random population
     */
    initializePopulation() {
        this.population = [];
        for (let i = 0; i < this.populationSize; i++) {
            const individual = this.bounds.generateRandomIndividual();
            individual.generation = 0;
            this.population.push(individual);
        }
    }

    /**
     * Start the optimization process
     */
    async start() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.generation = 0;

        console.log('üöÄ Starting NSGA-II optimization...');

        // Initialize population
        this.initializePopulation();

        // Report initial evaluation start
        this.onProgress({
            generation: 0,
            maxGenerations: this.maxGenerations,
            populationSize: this.population.length,
            paretoFrontSize: 0,
            evaluating: true,
            phase: 'Evaluating initial population...'
        });

        // Evaluate initial population
        await this.evaluatePopulation(this.population);
        this.assignRanksAndCrowdingDistance(this.population);

        // Report initial evaluation completion
        const initialParetoFront = this.getParetoFront();
        this.onProgress({
            generation: 0,
            maxGenerations: this.maxGenerations,
            populationSize: this.population.length,
            paretoFrontSize: initialParetoFront.length,
            evaluating: false,
            phase: 'Initial population evaluated'
        });

        // Evolution loop
        while (this.isRunning && this.generation < this.maxGenerations) {
            await this.evolveGeneration();
            this.generation++;

            // Report progress
            const paretoFront = this.getParetoFront();
            this.onProgress({
                generation: this.generation,
                maxGenerations: this.maxGenerations,
                populationSize: this.population.length,
                paretoFrontSize: paretoFront.length,
                bestSolutions: paretoFront.slice(0, 3)
            });

            // Report new solutions
            paretoFront.forEach(solution => {
                if (solution.generation === this.generation) {
                    this.onSolution(solution);
                }
            });
        }

        this.isRunning = false;

        // Final results
        const finalResults = {
            generation: this.generation,
            population: this.population,
            paretoFront: this.getParetoFront(),
            stats: this.getOptimizationStats()
        };

        this.onComplete(finalResults);
        console.log('‚úÖ NSGA-II optimization completed');

        return finalResults;
    }

    /**
     * Stop the optimization
     */
    stop() {
        this.isRunning = false;
        console.log('‚èπÔ∏è NSGA-II optimization stopped');
    }

    /**
     * Evolve one generation
     */
    async evolveGeneration() {
        // Generate offspring through selection, crossover, and mutation
        const offspring = [];

        while (offspring.length < this.populationSize) {
            // Tournament selection
            const parent1 = this.operators.tournamentSelection(this.population);
            const parent2 = this.operators.tournamentSelection(this.population);

            // Crossover
            const [child1, child2] = this.operators.crossover(parent1, parent2);

            // Mutation
            const mutatedChild1 = this.operators.mutate(child1);
            const mutatedChild2 = this.operators.mutate(child2);

            mutatedChild1.generation = this.generation + 1;
            mutatedChild2.generation = this.generation + 1;

            offspring.push(mutatedChild1);
            if (offspring.length < this.populationSize) {
                offspring.push(mutatedChild2);
            }
        }

        // Evaluate offspring
        await this.evaluatePopulation(offspring);

        // Combine parent and offspring populations
        const combined = [...this.population, ...offspring];

        // Non-dominated sorting and crowding distance
        this.assignRanksAndCrowdingDistance(combined);

        // Environmental selection (select best N individuals)
        this.population = this.environmentalSelection(combined, this.populationSize);
    }

    /**
     * Evaluate population in parallel
     */
    async evaluatePopulation(population) {
        let completed = 0;
        const total = population.length;

        // Evaluate with progress reporting
        const evaluationPromises = population.map(async (individual) => {
            const result = await this.evaluator.evaluate(individual);
            completed++;

            // Report evaluation progress within the current generation
            if (this.onProgress && completed % Math.max(1, Math.floor(total / 10)) === 0) {
                this.onProgress({
                    generation: this.generation,
                    maxGenerations: this.maxGenerations,
                    populationSize: this.population.length,
                    paretoFrontSize: this.getParetoFront().length,
                    evaluationProgress: completed / total,
                    evaluating: true,
                    phase: `Evaluating solutions (${completed}/${total})`
                });
            }

            return result;
        });

        await Promise.all(evaluationPromises);
    }

    /**
     * Non-dominated sorting and crowding distance assignment
     */
    assignRanksAndCrowdingDistance(population) {
        // Reset attributes
        population.forEach(individual => {
            individual.dominationCount = 0;
            individual.dominatedSolutions = [];
            individual.rank = null;
            individual.crowdingDistance = 0;
        });

        // Fast non-dominated sorting
        const fronts = [[]];

        for (let i = 0; i < population.length; i++) {
            const p = population[i];

            for (let j = 0; j < population.length; j++) {
                if (i === j) continue;

                const q = population[j];

                if (p.dominates(q)) {
                    p.dominatedSolutions.push(q);
                } else if (q.dominates(p)) {
                    p.dominationCount++;
                }
            }

            if (p.dominationCount === 0) {
                p.rank = 0;
                fronts[0].push(p);
            }
        }

        let frontIndex = 0;
        while (fronts[frontIndex].length > 0) {
            const nextFront = [];

            for (const p of fronts[frontIndex]) {
                for (const q of p.dominatedSolutions) {
                    q.dominationCount--;
                    if (q.dominationCount === 0) {
                        q.rank = frontIndex + 1;
                        nextFront.push(q);
                    }
                }
            }

            frontIndex++;
            fronts.push(nextFront);
        }

        // Calculate crowding distance for each front
        fronts.forEach(front => {
            if (front.length > 0) {
                this.calculateCrowdingDistance(front);
            }
        });
    }

    /**
     * Calculate crowding distance for a front
     */
    calculateCrowdingDistance(front) {
        const objectives = ['uxScore', 'safetyScore', 'efficiencyScore'];

        front.forEach(individual => {
            individual.crowdingDistance = 0;
        });

        objectives.forEach(objective => {
            // Sort by objective value
            front.sort((a, b) => a[objective] - b[objective]);

            // Set boundary points to infinity
            front[0].crowdingDistance = Infinity;
            front[front.length - 1].crowdingDistance = Infinity;

            // Calculate distances for intermediate points
            const objectiveRange = front[front.length - 1][objective] - front[0][objective];

            if (objectiveRange > 0) {
                for (let i = 1; i < front.length - 1; i++) {
                    front[i].crowdingDistance +=
                        (front[i + 1][objective] - front[i - 1][objective]) / objectiveRange;
                }
            }
        });
    }

    /**
     * Environmental selection to maintain population size
     */
    environmentalSelection(population, targetSize) {
        // Sort by rank first, then by crowding distance
        population.sort((a, b) => {
            if (a.rank !== b.rank) {
                return a.rank - b.rank;
            }
            return b.crowdingDistance - a.crowdingDistance;
        });

        return population.slice(0, targetSize);
    }

    /**
     * Get current Pareto front (rank 0 individuals)
     */
    getParetoFront() {
        return this.population.filter(individual => individual.rank === 0);
    }

    /**
     * Get optimization statistics
     */
    getOptimizationStats() {
        const paretoFront = this.getParetoFront();

        const stats = {
            generations: this.generation,
            populationSize: this.population.length,
            paretoFrontSize: paretoFront.length,
            feasibleSolutions: this.population.filter(ind => ind.isFeasible).length,
            averageEvaluationTime: this.population.reduce((sum, ind) => sum + ind.evaluationTime, 0) / this.population.length
        };

        if (paretoFront.length > 0) {
            stats.bestUX = Math.max(...paretoFront.map(ind => ind.uxScore));
            stats.bestSafety = Math.max(...paretoFront.map(ind => ind.safetyScore));
            stats.bestEfficiency = Math.max(...paretoFront.map(ind => ind.efficiencyScore));
        }

        return stats;
    }
}

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { NSGAII, Individual, TaikoFeeEvaluator };
}

// Make available globally
window.NSGAII = NSGAII;
window.Individual = Individual;
window.TaikoFeeEvaluator = TaikoFeeEvaluator;


// === optimization-research.js ===
/**
 * Interactive Parameter Optimization Research Interface
 *
 * Main controller for the optimization research tab featuring:
 * - Interactive weight configuration for 11 optimization metrics
 * - Real-time 3D Pareto frontier visualization
 * - NSGA-II multi-objective optimization
 * - Scientific research interface for protocol designers
 */

class OptimizationResearchController {
    constructor() {
        this.currentWeights = this.getDefaultWeights();
        this.lockedWeights = {
            ux: new Set(),
            safety: new Set(),
            efficiency: new Set()
        };
        this.paretoVisualizer = null;
        this.optimizationEngine = null;
        this.isOptimizing = false;
        this.currentSolutions = [];
        this.metricDefinitions = this.getMetricDefinitions();
        this.activeMetricTooltip = null;

        this.init();
    }

    /**
     * Comprehensive metric definitions with formulas and explanations
     */
    getMetricDefinitions() {
        return {
            'fee_affordability': {
                name: 'Fee Affordability',
                formula: '\\mathcal{A}(f) = -\\log(1 + \\bar{f} \\times 1000)',
                objectiveVariable: '\\mathcal{A}(f)',
                highlightText: 'A(f)',
                explanation: 'Measures how affordable fees are for users by applying a logarithmic penalty to the average fee. Lower average fees result in higher affordability scores.',
                details: [
                    '‚Ä¢ $\\bar{f}$ is the average fee per gas unit over the simulation period',
                    '‚Ä¢ Multiplied by 1000 to convert from ETH to milli-ETH scale',
                    '‚Ä¢ Logarithmic function ensures diminishing returns - very high fees are severely penalized',
                    '‚Ä¢ Higher scores indicate more affordable fees for users'
                ],
                range: 'Range: (-‚àû, 0], Higher is better',
                category: 'ux'
            },
            'fee_stability': {
                name: 'Fee Stability',
                formula: '\\mathcal{S}(f) = 1 - \\text{CV}(f)',
                objectiveVariable: '\\mathcal{S}(f)',
                highlightText: 'S(f)',
                explanation: 'Measures fee consistency by using the coefficient of variation. More stable fees provide better user experience and predictability.',
                details: [
                    '‚Ä¢ $\\text{CV}(f) = \\frac{\\sigma_f}{\\bar{f}}$ is the coefficient of variation',
                    '‚Ä¢ $\\sigma_f$ is the standard deviation of fees',
                    '‚Ä¢ $\\bar{f}$ is the mean fee level',
                    '‚Ä¢ Subtracting from 1 makes higher values represent better stability'
                ],
                range: 'Range: (-‚àû, 1], Higher is better',
                category: 'ux'
            },
            'fee_predictability_1h': {
                name: 'Fee Predictability (1h)',
                formula: '\\mathcal{P}_{1h}(f) = 1 - \\frac{\\text{RMSE}_{1h}}{\\bar{f}}',
                objectiveVariable: '\\mathcal{P}_{1h}(f)',
                highlightText: 'P_{1h}(f)',
                explanation: 'Measures how well fees can be predicted over a 1-hour window using recent trends. Better predictability helps users plan transactions.',
                details: [
                    '‚Ä¢ $\\text{RMSE}_{1h}$ is the root mean square error of 1-hour predictions',
                    '‚Ä¢ Uses simple moving average or trend-based prediction',
                    '‚Ä¢ Normalized by mean fee to make it scale-invariant',
                    '‚Ä¢ Higher scores indicate more predictable fee patterns'
                ],
                range: 'Range: (-‚àû, 1], Higher is better',
                category: 'ux'
            },
            'fee_predictability_6h': {
                name: 'Fee Predictability (6h)',
                formula: '\\mathcal{P}_{6h}(f) = 1 - \\frac{\\text{RMSE}_{6h}}{\\bar{f}}',
                objectiveVariable: '\\mathcal{P}_{6h}(f)',
                highlightText: 'P_{6h}(f)',
                explanation: 'Measures how well fees can be predicted over a 6-hour window. Longer-term predictability for strategic transaction timing.',
                details: [
                    '‚Ä¢ $\\text{RMSE}_{6h}$ is the root mean square error of 6-hour predictions',
                    '‚Ä¢ Uses trend analysis over longer periods',
                    '‚Ä¢ Important for applications that need to plan ahead',
                    '‚Ä¢ Generally lower than 1h predictability due to longer prediction horizon'
                ],
                range: 'Range: (-‚àû, 1], Higher is better',
                category: 'ux'
            },
            'insolvency_protection': {
                name: 'Insolvency Protection',
                formula: '\\mathcal{I}(v) = 1 - P(V < V_{\\text{crit}})',
                objectiveVariable: 'P_{\\text{insol}}',
                highlightText: 'insol',
                explanation: 'Measures the probability that the vault remains solvent (above critical threshold) throughout the simulation period.',
                details: [
                    '‚Ä¢ $P(V < V_{\\text{crit}})$ is probability of vault falling below critical level',
                    '‚Ä¢ $V_{\\text{crit}}$ is typically 10% of target vault balance',
                    '‚Ä¢ Insolvency would halt the protocol or require emergency measures',
                    '‚Ä¢ Higher scores indicate better protection against protocol failure'
                ],
                range: 'Range: [0, 1], Higher is better',
                category: 'safety'
            },
            'deficit_duration': {
                name: 'Deficit Duration Control',
                formula: '\\mathcal{D}(v) = 1 - \\frac{\\sum (d_i \\cdot t_i)^2}{T \\cdot V_{\\text{target}}^2}',
                objectiveVariable: '\\mathcal{D}_{\\text{weighted}}',
                highlightText: 'weighted',
                explanation: 'Measures how quickly deficits are corrected, with stronger penalties for longer deficit periods.',
                details: [
                    '‚Ä¢ $d_i$ is the deficit amount at time step $i$',
                    '‚Ä¢ $t_i$ is the duration of deficit period',
                    '‚Ä¢ Squared terms heavily penalize extended deficits',
                    '‚Ä¢ Normalized by total time $T$ and target vault size'
                ],
                range: 'Range: (-‚àû, 1], Higher is better',
                category: 'safety'
            },
            'vault_stress': {
                name: 'Vault Stress Resilience',
                formula: '\\mathcal{R}(v) = \\frac{\\Delta V_{\\text{recovery}}}{\\Delta t_{\\text{stress}}}',
                objectiveVariable: '\\mathcal{R}_{\\text{stress}}',
                highlightText: 'stress',
                explanation: 'Measures how quickly the vault recovers during high-stress periods (rapid L1 cost increases).',
                details: [
                    '‚Ä¢ $\\Delta V_{\\text{recovery}}$ is vault balance improvement during stress',
                    '‚Ä¢ $\\Delta t_{\\text{stress}}$ is duration of high-stress period',
                    '‚Ä¢ Stress periods defined as top 10% of L1 cost spikes',
                    '‚Ä¢ Higher values indicate faster stress recovery'
                ],
                range: 'Range: [0, +‚àû), Higher is better',
                category: 'safety'
            },
            'continuous_underfunding': {
                name: 'Underfunding Resistance',
                formula: '\\mathcal{U}(v) = 1 - \\frac{T_{\\text{deficit}}}{T_{\\text{total}}}',
                objectiveVariable: 'P_{\\text{deficit}}',
                highlightText: 'deficit',
                explanation: 'Measures the fraction of time the vault spends in deficit, with penalty for continuous underfunding.',
                details: [
                    '‚Ä¢ $T_{\\text{deficit}}$ is total time spent below target balance',
                    '‚Ä¢ $T_{\\text{total}}$ is total simulation time',
                    '‚Ä¢ Extended underfunding periods receive additional penalties',
                    '‚Ä¢ Higher scores indicate better maintenance of target balance'
                ],
                range: 'Range: [0, 1], Higher is better',
                category: 'safety'
            },
            'vault_utilization': {
                name: 'Vault Utilization',
                formula: '\\mathcal{V}(v) = 1 - \\frac{\\overline{|V - V_{\\text{target}}|}}{V_{\\text{target}}}',
                objectiveVariable: '\\mathcal{U}_{\\text{vault}}',
                highlightText: 'vault',
                explanation: 'Measures how close the vault balance stays to its optimal target level throughout the simulation.',
                details: [
                    '‚Ä¢ $\\overline{|V - V_{\\text{target}}|}$ is mean absolute deviation from target',
                    '‚Ä¢ $V_{\\text{target}}$ is the optimal vault balance',
                    '‚Ä¢ Penalizes both over and underfunding equally',
                    '‚Ä¢ Higher scores indicate better capital utilization'
                ],
                range: 'Range: (-‚àû, 1], Higher is better',
                category: 'efficiency'
            },
            'deficit_correction': {
                name: 'Deficit Correction Rate',
                formula: '\\mathcal{C}(v) = \\frac{\\sum \\Delta d_i}{\\sum \\Delta t_i}',
                objectiveVariable: '\\mathcal{C}_{\\text{correction}}',
                highlightText: 'correction',
                explanation: 'Measures the average rate at which deficits are corrected when they occur.',
                details: [
                    '‚Ä¢ $\\Delta d_i$ is deficit reduction in period $i$',
                    '‚Ä¢ $\\Delta t_i$ is time duration of correction period',
                    '‚Ä¢ Only considers periods when vault is actively correcting deficits',
                    '‚Ä¢ Higher rates indicate more efficient deficit correction'
                ],
                range: 'Range: [0, +‚àû), Higher is better',
                category: 'efficiency'
            },
            'capital_efficiency': {
                name: 'Capital Efficiency',
                formula: '\\mathcal{E}(v) = \\frac{\\text{Coverage}}{\\text{Capital Held}} \\times \\text{Utilization Factor}',
                objectiveVariable: '\\mathcal{E}_{\\text{capital}}',
                highlightText: 'capital',
                explanation: 'Measures how effectively the vault uses its capital to provide operational coverage.',
                details: [
                    '‚Ä¢ Coverage is the total L1 costs successfully covered',
                    '‚Ä¢ Capital Held is the average vault balance maintained',
                    '‚Ä¢ Utilization Factor accounts for idle vs. active capital',
                    '‚Ä¢ Higher efficiency means better capital productivity'
                ],
                range: 'Range: [0, +‚àû), Higher is better',
                category: 'efficiency'
            }
        };
    }

    /**
     * Initialize the research interface
     */
    init() {
        this.setupTabSwitching();
        this.setupMethodologyPanel();
        this.setupWeightSliders();
        this.setupWeightPresets();
        this.setupOptimizationControls();
        this.setupAnimationControls();
        this.setupMetricTooltips();
        // Don't initialize visualization immediately - wait for tab to be visible
        this.updateLiveFormulas();
        this.updateFormulaDisplay();

        // Check if optimization tab is active on load
        this.checkInitialTabState();

        console.log('üß¨ Optimization Research Interface initialized');
    }

    /**
     * Check if optimization tab is active on initial page load
     */
    checkInitialTabState() {
        const activeTab = document.querySelector('.research-tab-button.active');
        if (activeTab && activeTab.dataset.tab === 'optimization') {
            // Optimization tab is active and visible, safe to initialize visualization
            console.log('üéØ Optimization tab is active on load, initializing visualization...');
            if (!this.paretoVisualizer) {
                // Wait a bit for DOM to be fully ready and visible
                setTimeout(() => {
                    const container = document.querySelector('#pareto-visualization');
                    if (container && container.clientWidth > 0 && container.clientHeight > 0) {
                        console.log('üìä Container visible, initializing visualization...');
                        this.initializeParetoVisualization();
                    } else {
                        console.warn('‚ö†Ô∏è Container not visible yet, will retry when tab is switched');
                    }
                }, 300);
            }
        }
    }

    /**
     * Get default weight values from revised framework
     */
    getDefaultWeights() {
        return {
            // User Experience Weights (sum = 1.0)
            w1_fee_affordability: 0.40,
            w2_fee_stability: 0.30,
            w3_fee_predictability_1h: 0.20,
            w4_fee_predictability_6h: 0.10,

            // Protocol Safety Weights (sum = 1.0)
            w5_insolvency_protection: 0.40,
            w6_deficit_duration: 0.30,
            w7_vault_stress: 0.20,
            w8_continuous_underfunding: 0.10,

            // Economic Efficiency Weights (sum = 1.0)
            w9_vault_utilization: 0.40,
            w10_deficit_correction: 0.30,
            w11_capital_efficiency: 0.30
        };
    }

    /**
     * Normalize weight names from short IDs to canonical keys
     */
    getCanonicalWeightName(weightName) {
        const map = {
            w1: 'w1_fee_affordability',
            w2: 'w2_fee_stability',
            w3: 'w3_fee_predictability_1h',
            w4: 'w4_fee_predictability_6h',
            w5: 'w5_insolvency_protection',
            w6: 'w6_deficit_duration',
            w7: 'w7_vault_stress',
            w8: 'w8_continuous_underfunding',
            w9: 'w9_vault_utilization',
            w10: 'w10_deficit_correction',
            w11: 'w11_capital_efficiency'
        };

        return map[weightName] || weightName;
    }

    /**
     * Setup methodology panel toggle and interactions
     */
    setupMethodologyPanel() {
        const methodologyToggle = document.getElementById('methodology-toggle');
        const methodologyContent = document.getElementById('methodology-content');

        if (methodologyToggle && methodologyContent) {
            // Initially expanded
            methodologyToggle.addEventListener('click', () => {
                methodologyContent.classList.toggle('collapsed');
                methodologyToggle.classList.toggle('collapsed');
            });
        }

        // Initialize MathJax if available
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([methodologyContent]).catch((err) =>
                console.warn('MathJax rendering error:', err)
            );
        }
    }

    /**
     * Setup tab switching functionality
     */
    setupTabSwitching() {
        const tabButtons = document.querySelectorAll('.research-tab-button');
        const tabContents = document.querySelectorAll('.research-tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                // Ensure tab switching always works, even during loading
                event.stopPropagation();
                event.preventDefault();

                const targetTab = button.dataset.tab;

                // Force immediate tab switch (no delays that could be interfered with by loading)
                this.immediateTabSwitch(targetTab, button, tabButtons, tabContents);

                // Initialize visualization when switching to optimization tab
                if (targetTab === 'optimization') {
                    // Wait for tab content to be visible before initializing
                    setTimeout(() => {
                        const container = document.querySelector('#pareto-visualization');
                        if (container && container.clientWidth > 0 && container.clientHeight > 0) {
                            if (!this.paretoVisualizer) {
                                console.log('üìä Optimization tab now visible, initializing 3D visualization...');
                                this.initializeParetoVisualization();
                            } else if (this.paretoVisualizer.renderer &&
                                     (this.paretoVisualizer.renderer.getSize().width === 0 ||
                                      this.paretoVisualizer.renderer.getSize().height === 0)) {
                                // Visualizer exists but was created with 0√ó0 size, force resize
                                console.log('üîß Resizing 3D visualization for visible container...');
                                this.paretoVisualizer.handleResize();
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Container not visible yet during tab switch');
                        }
                    }, 200);
                }

                console.log(`üîÑ Switched to ${targetTab} tab`);
            });
        });

        // Setup feedback panel toggle
        const feedbackToggle = document.getElementById('feedback-toggle');
        const feedbackContent = document.getElementById('feedback-content');

        if (feedbackToggle && feedbackContent) {
            feedbackToggle.addEventListener('click', () => {
                feedbackContent.classList.toggle('collapsed');
                feedbackToggle.classList.toggle('collapsed');
            });
        }
    }

    /**
     * Immediately switch tabs without any delays or blocking
     */
    immediateTabSwitch(targetTab, activeButton, tabButtons, tabContents) {
        // Force immediate visual feedback - update button states
        tabButtons.forEach(btn => {
            btn.classList.remove('active');
            btn.style.pointerEvents = 'auto'; // Ensure buttons stay clickable
        });
        activeButton.classList.add('active');

        // Force immediate content visibility switch
        tabContents.forEach(content => {
            content.classList.remove('active');
            content.style.display = 'none'; // Force hide immediately
            if (content.id === `${targetTab}-tab-content`) {
                content.classList.add('active');
                content.style.display = 'block'; // Force show immediately
                content.style.opacity = '1'; // Ensure visibility
            }
        });

        console.log(`üîÑ Immediately switched to ${targetTab} tab`);
    }

    /**
     * Setup weight slider controls and normalization
     */
    setupWeightSliders() {
        const categories = ['ux', 'safety', 'efficiency'];

        categories.forEach(category => {
            const sliders = document.querySelectorAll(`[data-category="${category}"] .weight-slider`);
            console.log(`üéõÔ∏è Found ${sliders.length} sliders for category: ${category}`);

            sliders.forEach(slider => {
                const originalName = slider.dataset.weight;
                const weightName = this.getCanonicalWeightName(originalName);

                // Normalize data-weight so all downstream logic uses canonical keys
                slider.dataset.weight = weightName;

                // Align lock button data attributes with canonical key
                const lockBtn = slider.parentElement?.querySelector('.lock-weight, .weight-lock, .pin-weight');
                if (lockBtn) {
                    lockBtn.dataset.weight = weightName;
                }

                if (this.currentWeights[weightName] !== undefined) {
                    slider.value = this.currentWeights[weightName];
                    this.updateSliderDisplay(slider);
                } else {
                    console.warn(`Warning: Weight ${weightName} not found in currentWeights`);
                }

                // Add event listeners
                slider.addEventListener('input', () => {
                    this.handleWeightChange(slider, category);
                });

                slider.addEventListener('change', () => {
                    this.normalizeWeightsWithLocks(category, weightName);
                    this.updateLiveFormulas();
                    this.updateFormulaDisplay();
                    this.updateWeightsAndEngine();
                });
            });

            // Lock buttons for the category
            const lockButtons = document.querySelectorAll(`[data-category="${category}"] .pin-weight, [data-category="${category}"] .weight-lock, [data-category="${category}"] .lock-weight`);
            lockButtons.forEach(btn => {
                btn.addEventListener('click', () => this.toggleWeightLock(btn, category));
            });
        });

        console.log('üéõÔ∏è Current weights:', this.currentWeights);
    }

    /**
     * Setup weight preset buttons functionality
     */
    setupWeightPresets() {
        // Define weight presets for different optimization strategies
        const weightPresets = {
            'balanced': {
                name: '‚öñÔ∏è Balanced',
                description: 'Equal emphasis on all three objectives',
                weights: {
                    // User Experience (emphasis on affordability and stability)
                    w1_fee_affordability: 0.35,
                    w2_fee_stability: 0.35,
                    w3_fee_predictability_1h: 0.20,
                    w4_fee_predictability_6h: 0.10,

                    // Protocol Safety (emphasis on insolvency protection)
                    w5_insolvency_protection: 0.40,
                    w6_deficit_duration: 0.25,
                    w7_vault_stress: 0.25,
                    w8_continuous_underfunding: 0.10,

                    // Economic Efficiency (balanced across all metrics)
                    w9_vault_utilization: 0.35,
                    w10_deficit_correction: 0.35,
                    w11_capital_efficiency: 0.30
                }
            },
            'ux-focused': {
                name: 'üë• UX Focused',
                description: 'Prioritizes user experience - lower fees and predictability',
                weights: {
                    // User Experience (maximum emphasis on affordability)
                    w1_fee_affordability: 0.60,
                    w2_fee_stability: 0.25,
                    w3_fee_predictability_1h: 0.10,
                    w4_fee_predictability_6h: 0.05,

                    // Protocol Safety (minimum viable safety)
                    w5_insolvency_protection: 0.70,
                    w6_deficit_duration: 0.15,
                    w7_vault_stress: 0.10,
                    w8_continuous_underfunding: 0.05,

                    // Economic Efficiency (focus on capital efficiency)
                    w9_vault_utilization: 0.20,
                    w10_deficit_correction: 0.20,
                    w11_capital_efficiency: 0.60
                }
            },
            'safety-focused': {
                name: 'üõ°Ô∏è Safety Focused',
                description: 'Prioritizes protocol safety and stability above all',
                weights: {
                    // User Experience (minimal emphasis, basic affordability)
                    w1_fee_affordability: 0.25,
                    w2_fee_stability: 0.40,
                    w3_fee_predictability_1h: 0.25,
                    w4_fee_predictability_6h: 0.10,

                    // Protocol Safety (maximum emphasis on all safety metrics)
                    w5_insolvency_protection: 0.35,
                    w6_deficit_duration: 0.30,
                    w7_vault_stress: 0.25,
                    w8_continuous_underfunding: 0.10,

                    // Economic Efficiency (focus on vault stability)
                    w9_vault_utilization: 0.50,
                    w10_deficit_correction: 0.30,
                    w11_capital_efficiency: 0.20
                }
            },
            'efficiency-focused': {
                name: 'üí∞ Efficiency Focused',
                description: 'Maximizes economic efficiency and capital utilization',
                weights: {
                    // User Experience (efficiency-oriented - stable fees)
                    w1_fee_affordability: 0.20,
                    w2_fee_stability: 0.40,
                    w3_fee_predictability_1h: 0.25,
                    w4_fee_predictability_6h: 0.15,

                    // Protocol Safety (efficient safety measures)
                    w5_insolvency_protection: 0.30,
                    w6_deficit_duration: 0.20,
                    w7_vault_stress: 0.30,
                    w8_continuous_underfunding: 0.20,

                    // Economic Efficiency (maximum emphasis on all efficiency metrics)
                    w9_vault_utilization: 0.25,
                    w10_deficit_correction: 0.35,
                    w11_capital_efficiency: 0.40
                }
            }
        };

        // Add click handlers to preset buttons
        const presetButtons = document.querySelectorAll('.quick-presets .preset-btn');
        presetButtons.forEach(button => {
            button.addEventListener('click', () => {
                const presetKey = button.dataset.preset;
                const preset = weightPresets[presetKey];

                if (preset) {
                    this.applyWeightPreset(preset);
                    this.setActivePresetButton(button, presetButtons);
                    console.log(`üéØ Applied weight preset: ${preset.name}`);
                } else {
                    console.warn(`Unknown preset: ${presetKey}`);
                }
            });
        });

        console.log('üéØ Setup weight presets for', presetButtons.length, 'buttons');
    }

    /**
     * Apply a weight preset configuration
     */
    applyWeightPreset(preset) {
        // Update internal weights
        this.currentWeights = { ...preset.weights };

        // Update all sliders to reflect new weights
        Object.keys(preset.weights).forEach(weightName => {
            const slider = document.querySelector(`[data-weight="${weightName}"]`);
            if (slider) {
                slider.value = preset.weights[weightName];
                this.updateSliderDisplay(slider);
            }
        });

        // Update all category displays
        ['ux', 'safety', 'efficiency'].forEach(category => {
            this.updateCategorySliders(category);
            this.updateCategorySum(category);
        });

        // Update formulas and prepare for next optimization
        this.updateLiveFormulas();
        this.updateFormulaDisplay();
        this.updateWeightsAndEngine();

        console.log('üìä Applied preset weights:', preset.weights);
    }

    /**
     * Set active state for preset button
     */
    setActivePresetButton(activeButton, allButtons) {
        // Remove active state from all buttons
        allButtons.forEach(btn => btn.classList.remove('active'));

        // Add active state to clicked button
        activeButton.classList.add('active');
    }

    /**
     * Handle individual weight changes with live preview
     */
    handleWeightChange(slider, category) {
        const weightName = this.getCanonicalWeightName(slider.dataset.weight);
        const newValue = parseFloat(slider.value);

        this.currentWeights[weightName] = newValue;
        this.updateSliderDisplay(slider);

        // Auto-normalize respecting locks
        this.normalizeWeightsWithLocks(category, weightName);
        this.updateLiveFormulas();
        this.updateFormulaDisplay();
    }

    /**
     * Normalize weights within category to sum to 1.0 (respecting locks)
     */
    normalizeWeightsWithLocks(category, changedWeightName = null) {
        const categoryWeights = this.getCategoryWeights(category);
        const locks = this.lockedWeights[category] || new Set();

        // Enforce lock limit (N-2)
        if (locks.size > categoryWeights.length - 2) {
            const first = locks.values().next().value;
            if (first) locks.delete(first);
        }

        const lockedSum = categoryWeights
            .filter(w => locks.has(w))
            .reduce((sum, w) => sum + this.currentWeights[w], 0);

        // Cap changed weight if it exceeds available budget
        if (changedWeightName && !locks.has(changedWeightName)) {
            const maxAllowed = Math.max(0, 1 - lockedSum);
            if (this.currentWeights[changedWeightName] > maxAllowed) {
                this.currentWeights[changedWeightName] = maxAllowed;
                const slider = document.querySelector(`[data-weight="${changedWeightName}"]`);
                if (slider) {
                    slider.value = maxAllowed;
                    this.updateSliderDisplay(slider);
                }
            }
        }

        const changedValue = changedWeightName ? this.currentWeights[changedWeightName] : 0;
        const remainingNames = categoryWeights.filter(w => !locks.has(w) && w !== changedWeightName);
        const remainingSum = remainingNames.reduce((sum, w) => sum + this.currentWeights[w], 0);
        const targetRemaining = Math.max(0, 1 - lockedSum - changedValue);

        if (remainingNames.length > 0) {
            if (remainingSum === 0) {
                const evenShare = targetRemaining / remainingNames.length;
                remainingNames.forEach(w => {
                    this.currentWeights[w] = evenShare;
                });
            } else {
                const scale = targetRemaining / remainingSum;
                remainingNames.forEach(w => {
                    this.currentWeights[w] = this.currentWeights[w] * scale;
                });
            }
        }

        this.updateCategorySliders(category);
        this.updateCategorySum(category);
    }

    /**
     * Get weight names for a category
     */
    getCategoryWeights(category) {
        const weights = {
            'ux': ['w1_fee_affordability', 'w2_fee_stability', 'w3_fee_predictability_1h', 'w4_fee_predictability_6h'],
            'safety': ['w5_insolvency_protection', 'w6_deficit_duration', 'w7_vault_stress', 'w8_continuous_underfunding'],
            'efficiency': ['w9_vault_utilization', 'w10_deficit_correction', 'w11_capital_efficiency']
        };
        return weights[category] || [];
    }

    /**
     * Update slider display values
     */
    updateSliderDisplay(slider) {
        const value = parseFloat(slider.value);
        const weightName = this.getCanonicalWeightName(slider.dataset.weight);

        // Update the corresponding span element by mapping weight names to display IDs
        const weightIdMap = {
            'w1_fee_affordability': 'w1-value',
            'w2_fee_stability': 'w2-value',
            'w3_fee_predictability_1h': 'w3-value',
            'w4_fee_predictability_6h': 'w4-value',
            'w5_insolvency_protection': 'w5-value',
            'w6_deficit_duration': 'w6-value',
            'w7_vault_stress': 'w7-value',
            'w8_continuous_underfunding': 'w8-value',
            'w9_vault_utilization': 'w9-value',
            'w10_deficit_correction': 'w10-value',
            'w11_capital_efficiency': 'w11-value'
        };

        const displayId = weightIdMap[weightName];
        if (displayId) {
            const valueSpan = document.getElementById(displayId);
            if (valueSpan) {
                valueSpan.textContent = value.toFixed(3);
            }
        }

        // Legacy approach for backwards compatibility
        const display = slider.nextElementSibling;
        if (display && display.classList.contains('weight-value')) {
            display.textContent = value.toFixed(3);
        }
    }

    /**
     * Update all sliders in a category
     */
    updateCategorySliders(category) {
        const sliders = document.querySelectorAll(`[data-category="${category}"] .weight-slider`);
        sliders.forEach(slider => {
            const weightName = this.getCanonicalWeightName(slider.dataset.weight);
            slider.value = this.currentWeights[weightName];
            this.updateSliderDisplay(slider);

            const lockBtn = slider.parentElement?.querySelector('.pin-weight, .weight-lock, .lock-weight');
            const isLocked = this.lockedWeights[category]?.has(weightName);
            if (lockBtn) {
                lockBtn.textContent = isLocked ? 'üîí' : 'üîì';
            }
            slider.disabled = !!isLocked;
        });
    }

    /**
     * Update category sum display
     */
    updateCategorySum(category) {
        const categoryWeights = this.getCategoryWeights(category);
        const sum = categoryWeights.reduce((total, w) => total + this.currentWeights[w], 0);

        const sumDisplay = document.querySelector(`#${category}-category-sum`) ||
                           document.querySelector(`#${category}-sum`);
        if (sumDisplay) {
            sumDisplay.textContent = sum.toFixed(3);

            // Visual feedback for normalization needed
            if (Math.abs(sum - 1.0) > 0.001) {
                sumDisplay.classList.add('needs-normalization');
            } else {
                sumDisplay.classList.remove('needs-normalization');
            }
        }
    }

    /**
     * Update live LaTeX formulas in methodology panel
     */
    updateLiveFormulas() {
        const w = this.currentWeights;

        // Update UX formula
        const uxFormula = document.getElementById('ux-formula');
        if (uxFormula) {
            uxFormula.innerHTML = `$$UX = ${w.w1_fee_affordability.toFixed(3)} \\cdot M_1 + ${w.w2_fee_stability.toFixed(3)} \\cdot M_2 + ${w.w3_fee_predictability_1h.toFixed(3)} \\cdot M_3 + ${w.w4_fee_predictability_6h.toFixed(3)} \\cdot M_4$$`;
        }

        // Update Safety formula
        const safetyFormula = document.getElementById('safety-formula');
        if (safetyFormula) {
            safetyFormula.innerHTML = `$$Safety = ${w.w5_insolvency_protection.toFixed(3)} \\cdot M_5 + ${w.w6_deficit_duration.toFixed(3)} \\cdot M_6 + ${w.w7_vault_stress.toFixed(3)} \\cdot M_7 + ${w.w8_continuous_underfunding.toFixed(3)} \\cdot M_8$$`;
        }

        // Update Efficiency formula
        const efficiencyFormula = document.getElementById('efficiency-formula');
        if (efficiencyFormula) {
            efficiencyFormula.innerHTML = `$$Efficiency = ${w.w9_vault_utilization.toFixed(3)} \\cdot M_9 + ${w.w10_deficit_correction.toFixed(3)} \\cdot M_{10} + ${w.w11_capital_efficiency.toFixed(3)} \\cdot M_{11}$$`;
        }

        // Re-render MathJax if available
        if (window.MathJax && window.MathJax.typesetPromise) {
            const formulaElements = [uxFormula, safetyFormula, efficiencyFormula].filter(el => el);
            window.MathJax.typesetPromise(formulaElements).catch((err) =>
                console.warn('MathJax re-rendering error:', err)
            );
        }
    }

    /**
     * Update the mathematical formula display
     */
    updateFormulaDisplay() {
        const w = this.currentWeights;

        const uxFormula = `${w.w1_fee_affordability.toFixed(3)} √ó M‚ÇÅ + ${w.w2_fee_stability.toFixed(3)} √ó M‚ÇÇ + ${w.w3_fee_predictability_1h.toFixed(3)} √ó M‚ÇÉ + ${w.w4_fee_predictability_6h.toFixed(3)} √ó M‚ÇÑ`;

        const safetyFormula = `${w.w5_insolvency_protection.toFixed(3)} √ó M‚ÇÖ + ${w.w6_deficit_duration.toFixed(3)} √ó M‚ÇÜ + ${w.w7_vault_stress.toFixed(3)} √ó M‚Çá + ${w.w8_continuous_underfunding.toFixed(3)} √ó M‚Çà`;

        const efficiencyFormula = `${w.w9_vault_utilization.toFixed(3)} √ó M‚Çâ + ${w.w10_deficit_correction.toFixed(3)} √ó M‚ÇÅ‚ÇÄ + ${w.w11_capital_efficiency.toFixed(3)} √ó M‚ÇÅ‚ÇÅ`;

        const formulaContainer = document.querySelector('.formula-display');
        if (formulaContainer) {
            formulaContainer.innerHTML = `
                <div class="formula-section">
                    <strong>UX Score:</strong><br>
                    <code>${uxFormula}</code>
                </div>
                <div class="formula-section">
                    <strong>Safety Score:</strong><br>
                    <code>${safetyFormula}</code>
                </div>
                <div class="formula-section">
                    <strong>Efficiency Score:</strong><br>
                    <code>${efficiencyFormula}</code>
                </div>
            `;
        }
    }

    /**
     * Toggle lock for a specific weight (limit locks to N-2 per category)
     */
    toggleWeightLock(button, category) {
        const weightName = this.getCanonicalWeightName(button.dataset.weight);
        const locks = this.lockedWeights[category] || new Set();
        if (locks.has(weightName)) {
            locks.delete(weightName);
        } else {
            if (locks.size >= this.getCategoryWeights(category).length - 2) {
                console.warn('Lock limit reached; unlock another weight first.');
                return;
            }
            locks.add(weightName);
        }
        this.lockedWeights[category] = locks;
        this.updateCategorySliders(category);
        this.normalizeWeightsWithLocks(category);
        this.updateLiveFormulas();
        this.updateFormulaDisplay();
    }

    /**
     * Setup optimization control buttons
     */
    setupOptimizationControls() {
        const startBtn = document.querySelector('#start-optimization');
        const stopBtn = document.querySelector('#stop-optimization');
        const resetBtn = document.querySelector('#reset-optimization');
        const exportBtn = document.querySelector('#export-results');

        if (startBtn) {
            startBtn.addEventListener('click', () => this.startOptimization());
        }

        if (stopBtn) {
            stopBtn.addEventListener('click', () => this.stopOptimization());
        }

        if (resetBtn) {
            resetBtn.addEventListener('click', () => this.resetOptimization());
        }

        if (exportBtn) {
            exportBtn.addEventListener('click', () => this.exportResults());
        }

        // Setup remove duplicates button
        const removeDuplicatesBtn = document.querySelector('#remove-duplicates');
        if (removeDuplicatesBtn) {
            removeDuplicatesBtn.addEventListener('click', () => this.handleRemoveDuplicates());
        }

        // Setup solutions sort dropdown
        const sortDropdown = document.querySelector('#sort-solutions');
        if (sortDropdown) {
            sortDropdown.addEventListener('change', (e) => this.sortSolutions(e.target.value));
        }

        // Setup algorithm parameter sliders
        this.setupAlgorithmParameterSliders();
    }

    /**
     * Setup algorithm parameter slider controls
     */
    setupAlgorithmParameterSliders() {
        const sliders = [
            { id: 'population-slider', valueId: 'population-value' },
            { id: 'generations-slider', valueId: 'generations-value' },
            { id: 'crossover-slider', valueId: 'crossover-value' },
            { id: 'mutation-slider', valueId: 'mutation-value' }
        ];

        sliders.forEach(({ id, valueId }) => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);

            if (slider && valueDisplay) {
                slider.addEventListener('input', (event) => {
                    const value = parseFloat(event.target.value);

                    // Update display with appropriate formatting
                    if (id === 'crossover-slider' || id === 'mutation-slider') {
                        valueDisplay.textContent = value.toFixed(2);
                    } else {
                        valueDisplay.textContent = value.toString();
                    }

                    // Log for debugging
                    console.log(`üîß Algorithm parameter updated: ${id} = ${value}`);
                });

                // Initialize display with current value
                const currentValue = parseFloat(slider.value);
                if (id === 'crossover-slider' || id === 'mutation-slider') {
                    valueDisplay.textContent = currentValue.toFixed(2);
                } else {
                    valueDisplay.textContent = currentValue.toString();
                }
            } else {
                console.warn(`‚ö†Ô∏è Algorithm slider not found: ${id} or ${valueId}`);
            }
        });
    }

    /**
     * Get current algorithm parameters from sliders
     */
    getCurrentAlgorithmParameters() {
        const populationSlider = document.getElementById('population-slider');
        const generationsSlider = document.getElementById('generations-slider');
        const crossoverSlider = document.getElementById('crossover-slider');
        const mutationSlider = document.getElementById('mutation-slider');

        return {
            populationSize: populationSlider ? parseInt(populationSlider.value) : 100,
            maxGenerations: generationsSlider ? parseInt(generationsSlider.value) : 50,
            crossoverRate: crossoverSlider ? parseFloat(crossoverSlider.value) : 0.9,
            mutationRate: mutationSlider ? parseFloat(mutationSlider.value) : 0.1
        };
    }

    /**
     * Setup metric tooltip click handlers
     */
    setupMetricTooltips() {
        // Add click handlers to all metric tags
        const metricTags = document.querySelectorAll('.clickable-metric');

        metricTags.forEach(tag => {
            tag.addEventListener('click', (event) => {
                event.stopPropagation();
                const metricKey = tag.dataset.metric;
                this.showMetricTooltip(metricKey, tag);
            });

            // Add visual cue that it's clickable
            tag.style.cursor = 'pointer';
            tag.title = 'Click to see formula and explanation';
        });

        // Close tooltip when clicking outside
        document.addEventListener('click', () => {
            this.hideMetricTooltip();
        });

        console.log(`üî¨ Setup click handlers for ${metricTags.length} metric tags`);
    }

    /**
     * Show detailed metric tooltip with formula and explanation
     */
    showMetricTooltip(metricKey, targetElement) {
        const metric = this.metricDefinitions[metricKey];
        if (!metric) {
            console.warn(`Metric definition not found: ${metricKey}`);
            return;
        }

        // Remove any existing tooltip
        this.hideMetricTooltip();

        // Create tooltip element
        const tooltip = document.createElement('div');
        tooltip.className = 'metric-tooltip';
        tooltip.innerHTML = `
            <div class="tooltip-header">
                <h4>${metric.name}</h4>
                <button class="tooltip-close">&times;</button>
            </div>
            <div class="tooltip-content">
                <div class="formula-section">
                    <h5>Mathematical Formula:</h5>
                    <div class="formula-display" id="tooltip-formula-${metricKey}">
                        $$${metric.formula}$$
                    </div>
                </div>
                <div class="explanation-section">
                    <h5>Explanation:</h5>
                    <p>${metric.explanation}</p>
                </div>
                <div class="details-section">
                    <h5>Technical Details:</h5>
                    <ul>
                        ${metric.details.map(detail => `<li>${detail}</li>`).join('')}
                    </ul>
                </div>
                <div class="range-section">
                    <h5>Value Range:</h5>
                    <p><strong>${metric.range}</strong></p>
                </div>
            </div>
        `;

        // Position tooltip with smart positioning to keep it fully visible
        const rect = targetElement.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Calculate preferred position
        let top = rect.bottom + 15;
        let left = Math.max(20, rect.left - 300);

        // Adjust horizontal position if it would go off-screen
        const tooltipWidth = 600;
        if (left + tooltipWidth > viewportWidth - 20) {
            left = viewportWidth - tooltipWidth - 20;
        }

        // Adjust vertical position if it would go off-screen
        const estimatedHeight = 500; // Conservative estimate
        if (top + estimatedHeight > viewportHeight - 20) {
            // Position above the element instead
            top = Math.max(20, rect.top - estimatedHeight - 15);
        }

        tooltip.style.cssText = `
            position: fixed;
            top: ${top}px;
            left: ${left}px;
            width: ${tooltipWidth - 40}px;
            max-width: 90vw;
            max-height: 80vh;
            z-index: 10000;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            padding: 0;
            font-family: system-ui, sans-serif;
            animation: tooltipFadeIn 0.2s ease-out;
            overflow-y: auto;
        `;

        // Add close button handler
        const closeBtn = tooltip.querySelector('.tooltip-close');
        closeBtn.addEventListener('click', () => this.hideMetricTooltip());

        document.body.appendChild(tooltip);
        this.activeMetricTooltip = tooltip;

        // Highlight corresponding formula term
        this.highlightFormulaVariable(metric.highlightText, metric.category);

        // Render LaTeX if MathJax is available
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([tooltip]).catch((err) =>
                console.warn('MathJax tooltip rendering error:', err)
            );
        }

        console.log(`üìä Showing tooltip for ${metric.name}`);
    }

    /**
     * Hide the active metric tooltip
     */
    hideMetricTooltip() {
        if (this.activeMetricTooltip) {
            this.activeMetricTooltip.remove();
            this.activeMetricTooltip = null;

            // Remove any formula highlighting
            this.clearFormulaHighlighting();
        }
    }

    /**
     * Highlight the corresponding variable in the objective formula
     */
    highlightFormulaVariable(variable, category) {
        // Clear any existing highlighting first
        this.clearFormulaHighlighting();

        // Find the formula in the corresponding objective card
        const categoryCard = document.querySelector(`.${category}-card`);
        if (!categoryCard) return;

        const formulaContainer = categoryCard.querySelector('.mathematical-formulation');
        if (!formulaContainer) return;

        // Add highlighting class to the entire formula container for background effect
        formulaContainer.classList.add('formula-highlighted');

        // Now highlight the specific term in red
        this.highlightSpecificTerm(formulaContainer, variable);

        console.log(`‚ú® Highlighted formula variable ${variable} in ${category} category`);
    }

    /**
     * Highlight specific mathematical term in red
     */
    highlightSpecificTerm(container, highlightText) {
        // Wait for MathJax to finish rendering, then find and highlight the term
        setTimeout(() => {
            // Find all MathJax rendered elements
            const mathElements = container.querySelectorAll('.MathJax, .MathJax_Display, [id*="MathJax"]');

            if (mathElements.length === 0) {
                // Fallback: try to find mathml elements or other math containers
                const allMathContainers = container.querySelectorAll('*');
                for (let element of allMathContainers) {
                    if (element.textContent && element.textContent.includes(highlightText)) {
                        this.applyRedHighlightToTerm(element, highlightText);
                        break;
                    }
                }
            } else {
                // Search through MathJax elements
                mathElements.forEach(mathElement => {
                    this.applyRedHighlightToTerm(mathElement, highlightText);
                });
            }
        }, 300); // Give MathJax time to render
    }

    /**
     * Apply red highlighting to specific term within an element
     */
    applyRedHighlightToTerm(element, highlightText) {
        // Try different approaches to find and highlight the text
        const textContent = element.textContent || element.innerText;

        if (textContent && textContent.includes(highlightText)) {
            // Method 1: Try to find and wrap the text directly
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let textNode;
            while (textNode = walker.nextNode()) {
                const nodeText = textNode.textContent;
                if (nodeText.includes(highlightText)) {
                    const span = document.createElement('span');
                    span.className = 'formula-term-highlight';
                    span.style.cssText = 'color: #ef4444 !important; font-weight: bold; background: rgba(239, 68, 68, 0.1); padding: 1px 3px; border-radius: 3px;';

                    const highlightedText = nodeText.replace(
                        new RegExp(highlightText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'),
                        `<mark style="background: rgba(239, 68, 68, 0.2); color: #ef4444; font-weight: bold; padding: 1px 3px; border-radius: 3px;">$&</mark>`
                    );

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = highlightedText;

                    while (tempDiv.firstChild) {
                        textNode.parentNode.insertBefore(tempDiv.firstChild, textNode);
                    }
                    textNode.remove();
                    break;
                }
            }
        }
    }

    /**
     * Clear all formula highlighting
     */
    clearFormulaHighlighting() {
        // Remove background highlighting
        const highlightedFormulas = document.querySelectorAll('.formula-highlighted');
        highlightedFormulas.forEach(formula => {
            formula.classList.remove('formula-highlighted');
        });

        // Remove red term highlighting
        const highlightedTerms = document.querySelectorAll('.formula-term-highlight, mark[style*="color: #ef4444"]');
        highlightedTerms.forEach(term => {
            // Replace the highlighted element with its text content
            const parent = term.parentNode;
            if (parent) {
                parent.replaceChild(document.createTextNode(term.textContent), term);
                parent.normalize(); // Merge adjacent text nodes
            }
        });

        // Force MathJax to re-render to clean up any highlighting artifacts
        if (window.MathJax && window.MathJax.typesetPromise) {
            const formulaContainers = document.querySelectorAll('.mathematical-formulation');
            setTimeout(() => {
                window.MathJax.typesetPromise(formulaContainers).catch((err) =>
                    console.warn('MathJax re-render error:', err)
                );
            }, 100);
        }
    }

    /**
     * Setup animation controls panel and event handlers
     */
    setupAnimationControls() {
        const animationBtn = document.querySelector('#animation-settings');
        const animationPanel = document.querySelector('#animation-controls-panel');
        const closeBtn = document.querySelector('#close-animation-panel');

        // Toggle animation panel
        if (animationBtn && animationPanel) {
            animationBtn.addEventListener('click', () => {
                animationPanel.classList.toggle('hidden');
            });
        }

        // Close animation panel
        if (closeBtn && animationPanel) {
            closeBtn.addEventListener('click', () => {
                animationPanel.classList.add('hidden');
            });
        }

        // Animation controls
        this.setupAnimationEventHandlers();
    }

    /**
     * Setup individual animation control event handlers
     */
    setupAnimationEventHandlers() {
        // Animation enabled toggle
        const enabledCheckbox = document.querySelector('#animation-enabled');
        if (enabledCheckbox) {
            enabledCheckbox.addEventListener('change', (e) => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.toggleAnimation('enabled', e.target.checked);
                }
            });
        }

        // Animation speed slider
        const speedSlider = document.querySelector('#animation-speed');
        const speedValue = document.querySelector('#speed-value');
        if (speedSlider && speedValue) {
            speedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                speedValue.textContent = `${speed.toFixed(1)}x`;
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.setAnimationSpeed(speed);
                }
            });
        }

        // Rotation enabled toggle
        const rotationCheckbox = document.querySelector('#rotation-enabled');
        if (rotationCheckbox) {
            rotationCheckbox.addEventListener('change', (e) => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.toggleAnimation('rotationEnabled', e.target.checked);
                }
            });
        }

        // Pulse enabled toggle
        const pulseCheckbox = document.querySelector('#pulse-enabled');
        if (pulseCheckbox) {
            pulseCheckbox.addEventListener('change', (e) => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.toggleAnimation('pulseEnabled', e.target.checked);
                }
            });
        }

        // Auto-rotate camera toggle
        const autoRotateCheckbox = document.querySelector('#auto-rotate-camera');
        const cameraSpeedGroup = document.querySelector('#camera-speed-group');
        if (autoRotateCheckbox) {
            autoRotateCheckbox.addEventListener('change', (e) => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.toggleAnimation('autoRotateCamera', e.target.checked);
                }
                // Show/hide camera speed controls
                if (cameraSpeedGroup) {
                    cameraSpeedGroup.style.display = e.target.checked ? 'block' : 'none';
                }
            });
        }

        // Camera speed slider
        const cameraSpeedSlider = document.querySelector('#camera-speed');
        const cameraSpeedValue = document.querySelector('#camera-speed-value');
        if (cameraSpeedSlider && cameraSpeedValue) {
            cameraSpeedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                cameraSpeedValue.textContent = `${speed.toFixed(1)}x`;
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.setAnimationSettings({ cameraSpeed: speed });
                }
            });
        }

        // Trail enabled toggle
        const trailCheckbox = document.querySelector('#trail-enabled');
        if (trailCheckbox) {
            trailCheckbox.addEventListener('change', (e) => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.toggleAnimation('trailEnabled', e.target.checked);
                }
            });
        }

        // Reset animation settings
        const resetBtn = document.querySelector('#reset-animation');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => this.resetAnimationSettings());
        }

        // Reset camera position
        const resetCameraBtn = document.querySelector('#reset-camera');
        if (resetCameraBtn) {
            resetCameraBtn.addEventListener('click', () => {
                if (this.paretoVisualizer) {
                    this.paretoVisualizer.resetCameraPosition();
                }
            });
        }
    }

    /**
     * Reset animation settings to defaults
     */
    resetAnimationSettings() {
        const defaultSettings = {
            enabled: true,
            speed: 1.0,
            rotationEnabled: true,
            pulseEnabled: true,
            trailEnabled: false,
            autoRotateCamera: false,
            cameraSpeed: 0.5
        };

        // Update UI controls
        document.querySelector('#animation-enabled').checked = defaultSettings.enabled;
        document.querySelector('#animation-speed').value = defaultSettings.speed;
        document.querySelector('#speed-value').textContent = `${defaultSettings.speed.toFixed(1)}x`;
        document.querySelector('#rotation-enabled').checked = defaultSettings.rotationEnabled;
        document.querySelector('#pulse-enabled').checked = defaultSettings.pulseEnabled;
        document.querySelector('#trail-enabled').checked = defaultSettings.trailEnabled;
        document.querySelector('#auto-rotate-camera').checked = defaultSettings.autoRotateCamera;
        document.querySelector('#camera-speed').value = defaultSettings.cameraSpeed;
        document.querySelector('#camera-speed-value').textContent = `${defaultSettings.cameraSpeed.toFixed(1)}x`;
        document.querySelector('#camera-speed-group').style.display = 'none';

        // Apply to visualizer
        if (this.paretoVisualizer) {
            this.paretoVisualizer.setAnimationSettings(defaultSettings);
        }
    }

    /**
     * Setup 3D visualization container (placeholder only)
     */
    setupVisualization() {
        const container = document.querySelector('#pareto-visualization');
        if (container) {
            // Clear any existing content
            container.innerHTML = '';

            // Only show placeholder - actual initialization happens when tab is visible
            container.innerHTML = `
                <div class="visualization-placeholder">
                    <div class="placeholder-content">
                        <div class="placeholder-icon">üìä</div>
                        <h3>3D Visualization Ready</h3>
                        <p>Switch to the Optimization tab to initialize the Pareto frontier display</p>
                    </div>
                </div>
            `;

            console.log('üì¶ Visualization container prepared (initialization deferred)');
        }
    }

    /**
     * Initialize Three.js Pareto visualization with interaction callbacks
     */
    initializeParetoVisualization() {
        console.log('üîß Attempting to initialize ParetoVisualizer...');
        console.log('ParetoVisualizer available:', typeof ParetoVisualizer !== 'undefined');
        console.log('THREE available:', typeof THREE !== 'undefined');
        console.log('window.ParetoVisualizer:', !!window.ParetoVisualizer);

        const container = document.querySelector('#pareto-visualization');
        console.log('Container found:', !!container);
        if (container) {
            console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
        }

        if (typeof ParetoVisualizer !== 'undefined' && window.ParetoVisualizer) {
            try {
                console.log('‚úÖ Initializing ParetoVisualizer');
                this.paretoVisualizer = new ParetoVisualizer('#pareto-visualization');

                // Check if initialization was successful
                if (this.paretoVisualizer && this.paretoVisualizer.renderer) {
                    console.log('‚úÖ ParetoVisualizer renderer created successfully');

                    // Set up interaction callbacks
                    this.paretoVisualizer.setCallbacks({
                        onPointSelected: (solution) => this.handlePointSelection(solution),
                        onPointHovered: (solution) => this.handlePointHover(solution)
                    });

                    // 3D plot starts empty - users must run optimization to see results

                    console.log('üéØ Interactive 3D Pareto visualization initialized');
                } else {
                    throw new Error('ParetoVisualizer failed to initialize properly');
                }
            } catch (error) {
                console.error('‚ùå Error initializing ParetoVisualizer:', error);
                console.error('Error stack:', error.stack);
                this.showVisualizationError(error.message);
            }
        } else {
            console.warn('ParetoVisualizer not available');
            console.warn('typeof ParetoVisualizer:', typeof ParetoVisualizer);
            console.warn('window.ParetoVisualizer:', !!window.ParetoVisualizer);
            this.showVisualizationError('ParetoVisualizer class not found. Check script loading order.');
        }
    }


    /**
     * Show visualization error in the container
     */
    showVisualizationError(errorMessage) {
        const container = document.querySelector('#pareto-visualization');
        if (container) {
            container.innerHTML = `
                <div class="visualization-error">
                    <div class="error-content">
                        <div class="error-icon">‚ö†Ô∏è</div>
                        <h3>Visualization Error</h3>
                        <p>${errorMessage}</p>
                        <div class="error-details">
                            <p><strong>Debug Info:</strong></p>
                            <ul>
                                <li>THREE.js available: ${typeof THREE !== 'undefined'}</li>
                                <li>ParetoVisualizer available: ${typeof ParetoVisualizer !== 'undefined'}</li>
                                <li>Container found: ${!!container}</li>
                            </ul>
                        </div>
                        <button onclick="location.reload()" class="btn-secondary">Reload Page</button>
                    </div>
                </div>
            `;
        }
    }

    /**
     * Handle point selection in 3D visualization
     */
    handlePointSelection(solution, source = '3d') {
        console.log('üéØ Point selected:', solution, 'from:', source);

        // Update research feedback with selected solution details
        this.highlightSolutionInList(solution);
        this.updateSelectedSolutionMetrics(solution);

        // If selection comes from list, also highlight the 3D point
        if (source === 'list' && this.paretoVisualizer) {
            this.paretoVisualizer.selectPointBySolution(solution);
        }
    }

    /**
     * Handle point hover in 3D visualization
     */
    handlePointHover(solution) {
        // Could update real-time preview or highlight in solutions list
        this.previewSolutionMetrics(solution);
    }

    /**
     * Highlight solution in solutions list
     */
    highlightSolutionInList(solution) {
        const solutionsList = document.querySelector('.solutions-list');
        if (!solutionsList) return;

        // Remove previous highlights
        solutionsList.querySelectorAll('.solution-item').forEach(item => {
            item.classList.remove('selected');
        });

        // Find and highlight matching solution
        const solutionItems = solutionsList.querySelectorAll('.solution-item');
        solutionItems.forEach(item => {
            const params = item.querySelector('.solution-params strong');
            if (params && params.textContent.includes(`Œº=${solution.parameters?.mu?.toFixed(3) || solution.mu?.toFixed(3)}`)) {
                item.classList.add('selected');
                // Note: Removed scrollIntoView to prevent unwanted scrolling to duplicates
            }
        });
    }

    /**
     * Update metrics display for selected solution
     */
    updateSelectedSolutionMetrics(solution) {
        // Handle both parameter formats
        const mu = solution.parameters?.mu || solution.mu;
        const nu = solution.parameters?.nu || solution.nu;
        const H = solution.parameters?.horizon || solution.H;
        const uxScore = solution.scores?.ux || solution.uxScore;
        const safetyScore = solution.scores?.safety || solution.safetyScore;
        const efficiencyScore = solution.scores?.efficiency || solution.efficiencyScore;

        // Update parameter patterns section
        const muZeroRatio = document.getElementById('mu-zero-ratio');
        const avgNu = document.getElementById('avg-nu');
        const commonH = document.getElementById('common-h');

        if (muZeroRatio) {
            muZeroRatio.textContent = mu === 0 ? '‚úì Zero' : mu.toFixed(3);
        }
        if (avgNu) {
            avgNu.textContent = nu.toFixed(3);
        }
        if (commonH) {
            commonH.textContent = H.toString();
        }

        // Update objective score ranges to highlight this solution
        this.highlightObjectiveScore('ux', uxScore);
        this.highlightObjectiveScore('safety', safetyScore);
        this.highlightObjectiveScore('efficiency', efficiencyScore);

        // Display detailed solution panel
        this.displaySolutionDetails(solution);
    }

    /**
     * Preview solution metrics on hover (lighter feedback)
     */
    previewSolutionMetrics(solution) {
        // Could add subtle visual feedback here
        console.log('üëÄ Previewing solution:', solution.mu, solution.nu, solution.H);
    }

    /**
     * Highlight specific objective score
     */
    highlightObjectiveScore(objective, score) {
        const minSpan = document.getElementById(`${objective}-min`);
        const maxSpan = document.getElementById(`${objective}-max`);

        if (minSpan && maxSpan) {
            // Temporarily show the selected solution's score
            const originalMin = minSpan.textContent;
            const originalMax = maxSpan.textContent;

            minSpan.textContent = score.toFixed(3);
            maxSpan.textContent = score.toFixed(3);
            minSpan.style.fontWeight = 'bold';
            maxSpan.style.fontWeight = 'bold';

            // Reset after 2 seconds
            setTimeout(() => {
                minSpan.textContent = originalMin;
                maxSpan.textContent = originalMax;
                minSpan.style.fontWeight = 'normal';
                maxSpan.style.fontWeight = 'normal';
            }, 2000);
        }
    }

    /**
     * Export individual solution data
     */
    exportSolution(solutionDataString) {
        try {
            const solution = JSON.parse(solutionDataString.replace(/&quot;/g, '"'));

            const exportData = {
                solution: solution,
                weights: this.currentWeights,
                timestamp: new Date().toISOString(),
                type: 'individual_solution'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `taiko-solution-mu${solution.mu.toFixed(3)}-nu${solution.nu.toFixed(3)}-H${solution.H}-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('üìÅ Individual solution exported');
        } catch (error) {
            console.error('Failed to export solution:', error);
        }
    }

    /**
     * Display detailed information for selected solution
     */
    displaySolutionDetails(solution) {
        const detailsContainer = document.getElementById('solution-details');
        if (!detailsContainer) {
            console.warn('Solution details container not found');
            return;
        }

        // Extract solution data with fallbacks
        const mu = solution.parameters?.mu || solution.mu || 0;
        const nu = solution.parameters?.nu || solution.nu || 0;
        const H = solution.parameters?.horizon || solution.H || 0;

        const uxScore = solution.scores?.ux || solution.uxScore || 0;
        const safetyScore = solution.scores?.safety || solution.safetyScore || 0;
        const efficiencyScore = solution.scores?.efficiency || solution.efficiencyScore || 0;

        // Calculate overall score (weighted average)
        const overallScore = (uxScore + safetyScore + efficiencyScore) / 3;

        // Generate solution details HTML
        const detailsHTML = `
            <div class="solution-header">
                <div class="solution-title">
                    <h4>Selected Solution</h4>
                    <div class="solution-id">ID: ${solution.id || Math.floor(Date.now() / 1000)}</div>
                </div>
                <div class="overall-score">
                    <div class="score-value">${overallScore.toFixed(3)}</div>
                    <div class="score-label">Overall Score</div>
                </div>
            </div>

            <div class="solution-content">
                <div class="parameters-section">
                    <h5>üéõÔ∏è Parameters</h5>
                    <div class="parameter-grid">
                        <div class="parameter-item">
                            <span class="param-label">Œº (L1 Weight)</span>
                            <span class="param-value">${mu.toFixed(4)}</span>
                        </div>
                        <div class="parameter-item">
                            <span class="param-label">ŒΩ (Deficit Weight)</span>
                            <span class="param-value">${nu.toFixed(4)}</span>
                        </div>
                        <div class="parameter-item">
                            <span class="param-label">H (Horizon)</span>
                            <span class="param-value">${H} steps</span>
                        </div>
                    </div>
                </div>

                <div class="objectives-section">
                    <h5>üéØ Objective Scores</h5>
                    <div class="objective-scores">
                        <div class="objective-item ux">
                            <div class="objective-header">
                                <span class="objective-icon">üë•</span>
                                <span class="objective-name">User Experience</span>
                            </div>
                            <div class="objective-score">${uxScore.toFixed(3)}</div>
                            <div class="score-bar">
                                <div class="score-fill ux-fill" style="width: ${Math.max(5, Math.min(100, (uxScore + 1) * 50))}%"></div>
                            </div>
                        </div>

                        <div class="objective-item safety">
                            <div class="objective-header">
                                <span class="objective-icon">üõ°Ô∏è</span>
                                <span class="objective-name">Protocol Safety</span>
                            </div>
                            <div class="objective-score">${safetyScore.toFixed(3)}</div>
                            <div class="score-bar">
                                <div class="score-fill safety-fill" style="width: ${Math.max(5, Math.min(100, (safetyScore + 1) * 50))}%"></div>
                            </div>
                        </div>

                        <div class="objective-item efficiency">
                            <div class="objective-header">
                                <span class="objective-icon">üí∞</span>
                                <span class="objective-name">Economic Efficiency</span>
                            </div>
                            <div class="objective-score">${efficiencyScore.toFixed(3)}</div>
                            <div class="score-bar">
                                <div class="score-fill efficiency-fill" style="width: ${Math.max(5, Math.min(100, (efficiencyScore + 1) * 50))}%"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="actions-section">
                    <button class="btn btn-primary" onclick="alert('Apply parameters: Œº=${mu.toFixed(3)}, ŒΩ=${nu.toFixed(3)}, H=${H}')">
                        üìã Apply Parameters
                    </button>
                    <button class="btn btn-secondary" onclick="alert('Export feature coming soon!')">
                        üíæ Export Solution
                    </button>
                </div>
            </div>
        `;

        detailsContainer.innerHTML = detailsHTML;

        console.log('üìã Displayed solution details for:', {
            mu: mu.toFixed(3),
            nu: nu.toFixed(3),
            H,
            scores: { ux: uxScore.toFixed(3), safety: safetyScore.toFixed(3), efficiency: efficiencyScore.toFixed(3) }
        });
    }

    /**
     * Start the optimization process
     */
    async startOptimization() {
        if (this.isOptimizing) return;

        this.isOptimizing = true;
        this.updateOptimizationUI(true);

        try {
            // Initialize historical data if not already loaded
            if (!window.historicalDataLoader || !window.historicalDataLoader.loaded) {
                const progressText = document.querySelector('#progress-status');
                if (progressText) progressText.textContent = 'Loading historical datasets...';

                const loadSuccess = await window.historicalDataLoader.loadAllDatasets();
                if (!loadSuccess) {
                    throw new Error('Failed to load historical datasets');
                }

                if (progressText) progressText.textContent = 'Historical datasets loaded successfully';
            }

            // Get current algorithm parameters from sliders
            const algorithmParams = this.getCurrentAlgorithmParameters();

            // Initialize or reinitialize optimization engine with current parameters
            if (window.NSGAII) {
                this.optimizationEngine = new NSGAII({
                    populationSize: algorithmParams.populationSize,
                    maxGenerations: algorithmParams.maxGenerations,
                    crossoverRate: algorithmParams.crossoverRate,
                    mutationRate: algorithmParams.mutationRate,
                    weights: this.currentWeights,
                    onProgress: (progress) => this.handleOptimizationProgress(progress),
                    onSolution: (solution) => this.handleNewSolution(solution),
                    onComplete: (results) => this.handleOptimizationComplete(results)
                });

                console.log('üß¨ NSGA-II initialized with parameters:', algorithmParams);
                console.log('üéØ Algorithm rates - Crossover:', algorithmParams.crossoverRate, 'Mutation:', algorithmParams.mutationRate);
            }

            // Initialize visualization if needed
            if (!this.paretoVisualizer) {
                this.initializeParetoVisualization();
            }

            console.log('üöÄ Starting NSGA-II optimization with weights:', this.currentWeights);

            // Start real NSGA-II optimization
            if (this.optimizationEngine) {
                await this.optimizationEngine.start();
            } else {
                throw new Error('NSGA-II optimization engine not available');
            }

        } catch (error) {
            console.error('Optimization failed:', error);
            this.stopOptimization();
        }
    }

    /**
     * Handle optimization progress updates from NSGA-II
     */
    handleOptimizationProgress(progress) {
        console.log(`üìä Generation ${progress.generation}/${progress.maxGenerations}, Pareto Front: ${progress.paretoFrontSize}`);

        // Calculate detailed progress
        let detailedProgress = progress.generation;
        let statusText = `Generation ${progress.generation}/${progress.maxGenerations}`;

        // If we're in evaluation phase, show more granular progress
        if (progress.evaluating && progress.evaluationProgress) {
            detailedProgress = progress.generation - 1 + progress.evaluationProgress;
            statusText = progress.phase || `Generation ${progress.generation} - Evaluating...`;
        }

        // Update progress bar with detailed progress
        this.updateProgress(detailedProgress, progress.maxGenerations);

        // Update status text
        const progressText = document.querySelector('#progress-status');
        if (progressText) {
            progressText.textContent = statusText;
        }

        // Update progress stats
        const solutionsCount = document.querySelector('#solutions-count');
        const uniqueCount = document.querySelector('#unique-count');
        const paretoCount = document.querySelector('#pareto-count');
        const currentGeneration = document.querySelector('#current-generation');
        const totalGenerations = document.querySelector('#total-generations');

        if (solutionsCount) solutionsCount.textContent = progress.populationSize;
        if (uniqueCount) uniqueCount.textContent = this.getUniqueSolutionsCount();
        if (paretoCount) paretoCount.textContent = progress.paretoFrontSize;
        if (currentGeneration) currentGeneration.textContent = progress.generation;
        if (totalGenerations) totalGenerations.textContent = progress.maxGenerations;
    }

    /**
     * Check if a solution with identical parameters already exists
     */
    isDuplicateSolution(newSolution, tolerance = { mu: 0.001, nu: 0.001, H: 0 }) {
        return this.currentSolutions.some(existing =>
            Math.abs(existing.mu - newSolution.mu) <= tolerance.mu &&
            Math.abs(existing.nu - newSolution.nu) <= tolerance.nu &&
            Math.abs(existing.H - newSolution.H) <= tolerance.H
        );
    }

    /**
     * Add solution only if it's not a duplicate
     */
    addUniqueSolution(solution) {
        const solutionToAdd = {
            id: solution.id || Date.now() + Math.random(),
            mu: solution.mu,
            nu: solution.nu,
            H: solution.H,
            uxScore: solution.uxScore,
            safetyScore: solution.safetyScore,
            efficiencyScore: solution.efficiencyScore,
            isParetoOptimal: solution.rank === 0,
            generation: solution.generation
        };

        if (!this.isDuplicateSolution(solutionToAdd)) {
            this.currentSolutions.push(solutionToAdd);
            return true; // Solution was added
        }
        return false; // Solution was duplicate
    }

    /**
     * Get unique solutions count for display
     */
    getUniqueSolutionsCount() {
        const uniqueParams = new Set(
            this.currentSolutions.map(s => `${s.mu.toFixed(3)}-${s.nu.toFixed(3)}-${s.H}`)
        );
        return uniqueParams.size;
    }

    /**
     * Remove duplicate solutions from current list
     */
    removeDuplicates() {
        const unique = [];
        const seen = new Set();

        for (const solution of this.currentSolutions) {
            const key = `${solution.mu.toFixed(3)}-${solution.nu.toFixed(3)}-${solution.H}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(solution);
            }
        }

        const removedCount = this.currentSolutions.length - unique.length;
        this.currentSolutions = unique;

        console.log(`üßπ Removed ${removedCount} duplicate solutions`);
        return removedCount;
    }

    /**
     * Handle remove duplicates button click
     */
    handleRemoveDuplicates() {
        const removedCount = this.removeDuplicates();

        if (removedCount > 0) {
            // Update UI with new counts
            this.updateSolutionCounts();
            this.updateSolutionsList(this.currentSolutions);

            // Show confirmation message
            const progressStatus = document.querySelector('#progress-status');
            if (progressStatus) {
                const originalText = progressStatus.textContent;
                progressStatus.textContent = `Removed ${removedCount} duplicates`;
                progressStatus.classList.add('success');

                setTimeout(() => {
                    progressStatus.textContent = originalText;
                    progressStatus.classList.remove('success');
                }, 2000);
            }
        } else {
            console.log('‚ú® No duplicates found');
        }
    }

    /**
     * Update solution count displays
     */
    updateSolutionCounts() {
        const solutionsCount = document.querySelector('#solutions-count');
        const uniqueCount = document.querySelector('#unique-count');

        if (solutionsCount) solutionsCount.textContent = this.currentSolutions.length;
        if (uniqueCount) uniqueCount.textContent = this.getUniqueSolutionsCount();
    }

    /**
     * Handle new solution from NSGA-II
     */
    handleNewSolution(solution) {
        console.log('üß¨ New Pareto solution found:', {
            mu: solution.mu.toFixed(3),
            nu: solution.nu.toFixed(3),
            H: solution.H,
            ux: solution.uxScore.toFixed(3),
            safety: solution.safetyScore.toFixed(3),
            efficiency: solution.efficiencyScore.toFixed(3)
        });

        // Add to current solutions only if not duplicate
        const wasAdded = this.addUniqueSolution(solution);

        if (wasAdded) {
            // Add to visualization only if solution was actually added
            if (this.paretoVisualizer) {
                this.paretoVisualizer.addSolution({
                    uxScore: solution.uxScore,
                    safetyScore: solution.safetyScore,
                    efficiencyScore: solution.efficiencyScore,
                    isParetoOptimal: solution.rank === 0,
                    mu: solution.mu,
                    nu: solution.nu,
                    H: solution.H,
                    generation: solution.generation
                });
            }

            // Update solution counts and list
            this.updateSolutionCounts();
            this.updateSolutionsList(this.currentSolutions.slice(-20));
        } else {
            console.log('üîÑ Duplicate solution skipped');
        }
    }

    /**
     * Handle optimization completion from NSGA-II
     */
    handleOptimizationComplete(results) {
        console.log('‚úÖ NSGA-II optimization completed:', {
            generations: results.generation,
            totalSolutions: results.population.length,
            paretoSolutions: results.paretoFront.length
        });

        this.isOptimizing = false;
        this.updateOptimizationUI(false);

        // Add any final Pareto solutions that weren't added during progress
        let newSolutionsAdded = 0;
        const finalUniqueSolutions = [];

        for (const solution of results.paretoFront) {
            const wasAdded = this.addUniqueSolution({
                ...solution,
                isParetoOptimal: true,
                generation: solution.generation || results.generation
            });

            if (wasAdded) {
                newSolutionsAdded++;
                finalUniqueSolutions.push(solution);
            }
        }

        // Update final stats with unique counts
        const progressStatus = document.querySelector('#progress-status');
        const uniqueCount = this.getUniqueSolutionsCount();
        if (progressStatus) {
            progressStatus.textContent = `Complete (${uniqueCount} unique solutions, ${newSolutionsAdded} new)`;
        }

        console.log(`üéØ Final unique solutions: ${uniqueCount} (${newSolutionsAdded} newly added)`);

        // Update solutions list to show all current solutions
        this.updateSolutionsList(this.currentSolutions);
    }

    /**
     * Stop the optimization process
     */
    stopOptimization() {
        this.isOptimizing = false;
        this.updateOptimizationUI(false);

        if (this.optimizationEngine) {
            this.optimizationEngine.stop();
        }

        const progressStatus = document.querySelector('#progress-status');
        if (progressStatus) {
            progressStatus.textContent = 'Stopped';
        }

        console.log('‚èπÔ∏è Optimization stopped');
    }

    /**
     * Reset the optimization
     */
    resetOptimization() {
        this.stopOptimization();
        this.currentSolutions = [];

        if (this.paretoVisualizer) {
            this.paretoVisualizer.clear();
        }

        this.updateSolutionsList([]);
        this.updateProgress(0, 0);

        console.log('üîÑ Optimization reset');
    }

    /**
     * Test method to add duplicate solutions for testing deduplication
     * This method is only for testing purposes
     */
    addTestDuplicates() {
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('üß™ Adding test duplicate solutions...');

            // Add some test solutions with duplicates
            const testSolutions = [
                { mu: 0.0, nu: 0.1, H: 36, uxScore: 0.85, safetyScore: 0.78, efficiencyScore: 0.65, generation: 1 },
                { mu: 0.0, nu: 0.1, H: 36, uxScore: 0.85, safetyScore: 0.78, efficiencyScore: 0.65, generation: 2 }, // Duplicate
                { mu: 0.0, nu: 0.2, H: 72, uxScore: 0.82, safetyScore: 0.81, efficiencyScore: 0.70, generation: 3 },
                { mu: 0.0, nu: 0.1, H: 36, uxScore: 0.85, safetyScore: 0.78, efficiencyScore: 0.65, generation: 4 }, // Duplicate
                { mu: 0.0, nu: 0.3, H: 144, uxScore: 0.80, safetyScore: 0.85, efficiencyScore: 0.72, generation: 5 },
                { mu: 0.0, nu: 0.2, H: 72, uxScore: 0.82, safetyScore: 0.81, efficiencyScore: 0.70, generation: 6 }, // Duplicate
            ];

            // Add solutions directly (bypassing deduplication for testing)
            testSolutions.forEach(solution => {
                this.currentSolutions.push({
                    id: Date.now() + Math.random(),
                    ...solution,
                    isParetoOptimal: true
                });
            });

            this.updateSolutionCounts();
            this.updateSolutionsList(this.currentSolutions);
            this.updateOptimizationUI(false);

            console.log(`üß™ Added ${testSolutions.length} test solutions (includes duplicates)`);
            console.log(`   Unique solutions: ${this.getUniqueSolutionsCount()}`);
        }
    }

    /**
     * Update UI during optimization
     */
    updateOptimizationUI(isRunning) {
        const startBtn = document.querySelector('#start-optimization');
        const stopBtn = document.querySelector('#stop-optimization');
        const exportBtn = document.querySelector('#export-results');
        const progress = document.querySelector('#progress-fill');

        if (startBtn) {
            startBtn.disabled = isRunning;
            startBtn.textContent = isRunning ? 'Optimizing...' : 'Start Optimization';
        }

        if (stopBtn) {
            stopBtn.disabled = !isRunning;
        }

        if (exportBtn) {
            exportBtn.disabled = isRunning || this.currentSolutions.length === 0;
        }

        // Enable/disable remove duplicates button based on solutions availability
        const removeDuplicatesBtn = document.querySelector('#remove-duplicates');
        if (removeDuplicatesBtn) {
            removeDuplicatesBtn.disabled = isRunning || this.currentSolutions.length === 0;
        }

        if (progress && !isRunning) {
            progress.style.width = '0%';
        }
    }

    /**
     * Update weights and reinitialize optimization engine if needed
     */
    updateWeightsAndEngine() {
        // Reset optimization engine to use new weights
        if (this.optimizationEngine && !this.isOptimizing) {
            this.optimizationEngine = null;
        }

        console.log('üìä Weights updated, optimization engine will be reinitialized on next run');
    }

    /**
     * Update progress display
     */
    updateProgress(current, total) {
        const percentage = (current / total) * 100;
        const progressFill = document.querySelector('#progress-fill');
        const progressText = document.querySelector('#progress-status');

        if (progressFill) {
            progressFill.style.width = `${percentage}%`;
        }

        if (progressText) {
            progressText.textContent = `Generation ${current}/${total} (${percentage.toFixed(1)}%)`;
        }
    }

    /**
     * Update solutions list display
     */
    updateSolutionsList(solutions) {
        const container = document.querySelector('#solutions-list');
        if (!container) return;

        if (solutions.length === 0) {
            container.innerHTML = '<p>No solutions yet. Start optimization to generate Pareto optimal parameters.</p>';
            return;
        }

        const solutionsHTML = solutions.map((solution, index) => `
            <div class="solution-item ${solution.isParetoOptimal ? 'pareto-optimal' : ''}" data-solution-index="${index}">
                <div class="solution-params">
                    <strong>Œº=${solution.mu.toFixed(3)}, ŒΩ=${solution.nu.toFixed(3)}, H=${solution.H}</strong>
                </div>
                <div class="solution-scores">
                    <span class="score ux">UX: ${solution.uxScore.toFixed(3)}</span>
                    <span class="score safety">Safety: ${solution.safetyScore.toFixed(3)}</span>
                    <span class="score efficiency">Efficiency: ${solution.efficiencyScore.toFixed(3)}</span>
                </div>
                ${solution.isParetoOptimal ? '<div class="pareto-badge">Pareto Optimal</div>' : ''}
            </div>
        `).join('');

        container.innerHTML = solutionsHTML;

        // Add click handlers to solution items for selection
        container.querySelectorAll('.solution-item').forEach((item, index) => {
            item.addEventListener('click', () => {
                const solution = solutions[index];
                if (solution) {
                    // Remove previous selections
                    container.querySelectorAll('.solution-item').forEach(el => el.classList.remove('selected'));
                    // Mark this item as selected
                    item.classList.add('selected');
                    // Handle selection
                    this.handlePointSelection(solution, 'list');
                    console.log('üìä Solution selected from list:', solution);
                }
            });

            // Add visual feedback for clickability
            item.style.cursor = 'pointer';
            item.title = 'Click to view solution details';
        });

        console.log('üìä Updated solutions list with', solutions.length, 'solutions and click handlers');
    }

    /**
     * Sort solutions by specified criteria
     */
    sortSolutions(sortBy) {
        const container = document.querySelector('#solutions-list');
        if (!container) return;

        // Get current solutions from the DOM
        const solutionItems = Array.from(container.querySelectorAll('.solution-item'));
        if (solutionItems.length === 0) return;

        // Extract solution data from DOM elements
        const solutionsWithElements = solutionItems.map(item => {
            const paramsText = item.querySelector('.solution-params strong').textContent;
            const uxText = item.querySelector('.score.ux').textContent;
            const safetyText = item.querySelector('.score.safety').textContent;
            const efficiencyText = item.querySelector('.score.efficiency').textContent;

            // Parse parameters from text like "Œº=0.123, ŒΩ=0.456, H=72"
            const muMatch = paramsText.match(/Œº=([\d.]+)/);
            const nuMatch = paramsText.match(/ŒΩ=([\d.]+)/);
            const hMatch = paramsText.match(/H=(\d+)/);

            return {
                element: item,
                mu: muMatch ? parseFloat(muMatch[1]) : 0,
                nu: nuMatch ? parseFloat(nuMatch[1]) : 0,
                H: hMatch ? parseInt(hMatch[1]) : 0,
                uxScore: parseFloat(uxText.replace('UX: ', '')),
                safetyScore: parseFloat(safetyText.replace('Safety: ', '')),
                efficiencyScore: parseFloat(efficiencyText.replace('Efficiency: ', '')),
                isParetoOptimal: item.classList.contains('pareto-optimal')
            };
        });

        // Sort based on criteria
        let sortedSolutions;
        switch (sortBy) {
            case 'dominance':
                // Sort by Pareto optimal first, then by overall score
                sortedSolutions = solutionsWithElements.sort((a, b) => {
                    if (a.isParetoOptimal !== b.isParetoOptimal) {
                        return b.isParetoOptimal ? 1 : -1; // Pareto optimal first
                    }
                    const aOverall = (a.uxScore + a.safetyScore + a.efficiencyScore) / 3;
                    const bOverall = (b.uxScore + b.safetyScore + b.efficiencyScore) / 3;
                    return bOverall - aOverall; // Higher scores first
                });
                break;
            case 'ux':
                sortedSolutions = solutionsWithElements.sort((a, b) => b.uxScore - a.uxScore);
                break;
            case 'safety':
                sortedSolutions = solutionsWithElements.sort((a, b) => b.safetyScore - a.safetyScore);
                break;
            case 'efficiency':
                sortedSolutions = solutionsWithElements.sort((a, b) => b.efficiencyScore - a.efficiencyScore);
                break;
            default:
                sortedSolutions = solutionsWithElements; // No sorting
        }

        // Re-append elements in sorted order
        container.innerHTML = ''; // Clear container
        sortedSolutions.forEach(({ element }) => {
            container.appendChild(element);
        });

        console.log(`üìä Solutions sorted by: ${sortBy}`);
    }

    /**
     * Export optimization results with comprehensive scientific documentation
     */
    exportResults() {
        const paretoSolutions = this.currentSolutions.filter(s => s.isParetoOptimal);

        const data = {
            metadata: {
                title: "Taiko Fee Mechanism Multi-Objective Optimization Results",
                description: "NSGA-II optimization results for Taiko protocol fee mechanism parameters",
                exportDate: new Date().toISOString(),
                version: "1.0.0",
                framework: "Revised Optimization Framework (Post-Timing-Fix)",
                algorithm: "NSGA-II (Non-dominated Sorting Genetic Algorithm II)"
            },
            configuration: {
                weights: {
                    user_experience: {
                        w1_fee_affordability: this.currentWeights.w1_fee_affordability,
                        w2_fee_stability: this.currentWeights.w2_fee_stability,
                        w3_fee_predictability_1h: this.currentWeights.w3_fee_predictability_1h,
                        w4_fee_predictability_6h: this.currentWeights.w4_fee_predictability_6h
                    },
                    protocol_safety: {
                        w5_insolvency_protection: this.currentWeights.w5_insolvency_protection,
                        w6_deficit_duration: this.currentWeights.w6_deficit_duration,
                        w7_vault_stress: this.currentWeights.w7_vault_stress,
                        w8_continuous_underfunding: this.currentWeights.w8_continuous_underfunding
                    },
                    economic_efficiency: {
                        w9_vault_utilization: this.currentWeights.w9_vault_utilization,
                        w10_deficit_correction: this.currentWeights.w10_deficit_correction,
                        w11_capital_efficiency: this.currentWeights.w11_capital_efficiency
                    }
                },
                constraints: {
                    six_step_alignment: "H must be divisible by 6 (batch cycle alignment)",
                    parameter_bounds: {
                        mu: "[0.0, 1.0] - L1 weight parameter",
                        nu: "[0.02, 1.0] - Deficit weight parameter",
                        H: "[6, 576] - Horizon parameter (6-step aligned)"
                    }
                }
            },
            optimization_results: {
                total_solutions_evaluated: this.currentSolutions.length,
                pareto_optimal_solutions: paretoSolutions.length,
                pareto_dominance_ratio: paretoSolutions.length / this.currentSolutions.length,
                convergence_metrics: {
                    hypervolume_indicator: "Not computed",
                    spacing_metric: "Not computed",
                    spread_metric: "Not computed"
                }
            },
            pareto_front: paretoSolutions.map(solution => ({
                parameters: {
                    mu: solution.mu,
                    nu: solution.nu,
                    H: solution.H
                },
                objectives: {
                    ux_score: solution.uxScore,
                    safety_score: solution.safetyScore,
                    efficiency_score: solution.efficiencyScore
                },
                generation: solution.generation || 0,
                rank: 0 // All Pareto solutions have rank 0
            })),
            dominated_solutions: this.currentSolutions
                .filter(s => !s.isParetoOptimal)
                .map(solution => ({
                    parameters: {
                        mu: solution.mu,
                        nu: solution.nu,
                        H: solution.H
                    },
                    objectives: {
                        ux_score: solution.uxScore,
                        safety_score: solution.safetyScore,
                        efficiency_score: solution.efficiencyScore
                    },
                    generation: solution.generation || 0
                })),
            recommendations: this.generateRecommendations(paretoSolutions),
            methodology: {
                objective_functions: {
                    user_experience: "UX = Œ£(wi √ó Mi) where Mi ‚àà {fee_affordability, fee_stability, predictability_1h, predictability_6h}",
                    protocol_safety: "Safety = Œ£(wi √ó Mi) where Mi ‚àà {insolvency_protection, deficit_duration, vault_stress, continuous_underfunding}",
                    economic_efficiency: "Efficiency = Œ£(wi √ó Mi) where Mi ‚àà {vault_utilization, deficit_correction, capital_efficiency}"
                },
                pareto_dominance: "Solution A dominates B if A is at least as good as B in all objectives and strictly better in at least one",
                constraint_handling: "6-step batch alignment enforced as hard constraint during parameter generation",
                normalization: "All objectives normalized to [0,1] range for fair comparison"
            },
            references: {
                taiko_protocol: "https://taiko.xyz/",
                nsga_ii_paper: "Deb, K., et al. 'A fast and elitist multiobjective genetic algorithm: NSGA-II' (2002)",
                eip_1559: "https://eips.ethereum.org/EIPS/eip-1559"
            }
        };

        // Generate multiple export formats
        this.exportJSON(data);
        this.exportCSV(paretoSolutions);

        console.log('üìÅ Comprehensive results exported in JSON and CSV formats');
    }

    /**
     * Export JSON format
     */
    exportJSON(data) {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `taiko-fee-optimization-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    /**
     * Export CSV format for data analysis
     */
    exportCSV(paretoSolutions) {
        const headers = [
            'mu', 'nu', 'H',
            'ux_score', 'safety_score', 'efficiency_score',
            'generation', 'is_pareto_optimal'
        ];

        const csvData = [
            headers.join(','),
            ...this.currentSolutions.map(solution => [
                solution.mu,
                solution.nu,
                solution.H,
                solution.uxScore,
                solution.safetyScore,
                solution.efficiencyScore,
                solution.generation || 0,
                solution.isParetoOptimal ? 1 : 0
            ].join(','))
        ].join('\n');

        const blob = new Blob([csvData], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `taiko-fee-pareto-solutions-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    /**
     * Generate optimization recommendations
     */
    generateRecommendations(paretoSolutions) {
        if (paretoSolutions.length === 0) {
            return { error: "No Pareto optimal solutions found" };
        }

        // Find representative solutions
        const bestUX = paretoSolutions.reduce((best, current) =>
            current.uxScore > best.uxScore ? current : best
        );

        const bestSafety = paretoSolutions.reduce((best, current) =>
            current.safetyScore > best.safetyScore ? current : best
        );

        const bestEfficiency = paretoSolutions.reduce((best, current) =>
            current.efficiencyScore > best.efficiencyScore ? current : best
        );

        return {
            best_user_experience: {
                parameters: { mu: bestUX.mu, nu: bestUX.nu, H: bestUX.H },
                scores: { ux: bestUX.uxScore, safety: bestUX.safetyScore, efficiency: bestUX.efficiencyScore },
                use_case: "Optimize for lowest fees and highest predictability"
            },
            best_safety: {
                parameters: { mu: bestSafety.mu, nu: bestSafety.nu, H: bestSafety.H },
                scores: { ux: bestSafety.uxScore, safety: bestSafety.safetyScore, efficiency: bestSafety.efficiencyScore },
                use_case: "Maximize protocol safety and vault resilience"
            },
            best_efficiency: {
                parameters: { mu: bestEfficiency.mu, nu: bestEfficiency.nu, H: bestEfficiency.H },
                scores: { ux: bestEfficiency.uxScore, safety: bestEfficiency.safetyScore, efficiency: bestEfficiency.efficiencyScore },
                use_case: "Optimize capital utilization and deficit correction"
            },
            analysis: {
                parameter_patterns: {
                    mu_preference: paretoSolutions.filter(s => s.mu < 0.1).length / paretoSolutions.length,
                    average_nu: paretoSolutions.reduce((sum, s) => sum + s.nu, 0) / paretoSolutions.length,
                    common_horizons: [...new Set(paretoSolutions.map(s => s.H))].sort((a, b) => a - b)
                },
                trade_offs: "Higher safety scores typically require higher nu values, potentially reducing efficiency"
            }
        };
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.optimizationResearch = new OptimizationResearchController();
});

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = OptimizationResearchController;
}

// Export to global window object for browser usage
if (typeof window !== 'undefined') {
    window.OptimizationResearchController = OptimizationResearchController;
}


// === app.js ===
// Main application logic for Taiko Fee Explorer

class TaikoFeeExplorer {
    constructor() {
        this.chartManager = new ChartManager();
        this.currentSimulationData = null;
        this.isRunning = false;
        this.autoRunEnabled = true;
        this.autoRunDelay = 800; // ms delay after last parameter change

        this.initializeEventListeners();
        this.updateParameterDisplays();

        // Initialize minimum deficit rate visibility based on guaranteed recovery checkbox
        this.toggleMinDeficitRateVisibility(document.getElementById('guaranteed-recovery').checked);

        // Auto-run simulation on page load
        setTimeout(() => {
            this.runSimulation();
        }, 500);
    }

    initializeEventListeners() {
        // Parameter sliders
        document.getElementById('mu-slider').addEventListener('input', (e) => {
            document.getElementById('mu-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('nu-slider').addEventListener('input', (e) => {
            document.getElementById('nu-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('H-slider').addEventListener('input', (e) => {
            document.getElementById('H-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('volatility-slider').addEventListener('input', (e) => {
            document.getElementById('volatility-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('spike-delay-slider').addEventListener('input', (e) => {
            document.getElementById('spike-delay-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('spike-height-slider').addEventListener('input', (e) => {
            document.getElementById('spike-height-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('duration-slider').addEventListener('input', (e) => {
            document.getElementById('duration-value').textContent = parseFloat(e.target.value).toFixed(1);
            this.clearActivePreset();
            this.markParametersModified();
        });

        document.getElementById('tx-per-block-slider').addEventListener('input', (e) => {
            document.getElementById('tx-per-block-value').textContent = e.target.value;
            this.clearActivePreset();
            this.markParametersModified();
        });

        // Vault initialization
        document.getElementById('vault-init').addEventListener('change', () => {
            this.clearActivePreset();
            this.markParametersModified();
        });

        // Guaranteed recovery toggle
        document.getElementById('guaranteed-recovery').addEventListener('change', (e) => {
            this.toggleMinDeficitRateVisibility(e.target.checked);
            this.clearActivePreset();
            this.markParametersModified();
        });

        // Minimum deficit rate slider
        document.getElementById('min-deficit-rate-slider').addEventListener('input', (e) => {
            const exponentValue = parseFloat(e.target.value);
            const actualValue = Math.pow(10, exponentValue);
            document.getElementById('min-deficit-rate-value').textContent = actualValue.toExponential(3);
            this.clearActivePreset();
            this.markParametersModified();
        });

        // Tab buttons
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchTab(e.target.dataset.tab);
                this.clearActivePreset();
                this.runSimulation(); // Immediate update when switching data source
            });
        });

        // Historical period selection
        document.querySelectorAll('input[name="historical-period"]').forEach(radio => {
            radio.addEventListener('change', () => {
                this.clearActivePreset();
                this.runSimulation(); // Immediate update when changing historical periods
            });
        });

        // Seed input
        document.getElementById('seed-input').addEventListener('input', () => {
            this.clearActivePreset();
            this.markParametersModified();
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Check if tooltip trigger was clicked
                if (e.target.classList.contains('preset-tooltip-trigger')) {
                    e.stopPropagation();
                    const presetName = e.target.closest('.preset-btn').dataset.preset;
                    this.showPresetTooltip(presetName);
                    return;
                }

                const presetName = e.target.dataset.preset;
                this.loadPreset(presetName);
                this.setActivePreset(e.target);
            });
        });


        // Tooltips
        this.initializeTooltips();

        // Formula info modal
        this.initializeFormulaModal();

        // Preset tooltip modal
        this.initializePresetTooltip();
    }

    initializeTooltips() {
        // Simple tooltip implementation for general tooltips
        const tooltips = document.querySelectorAll('.tooltip');
        tooltips.forEach(tooltip => {
            let tooltipElement = null;

            tooltip.addEventListener('mouseenter', (e) => {
                const text = e.target.getAttribute('data-tooltip');
                tooltipElement = document.createElement('div');
                tooltipElement.className = 'tooltip-popup';
                tooltipElement.textContent = text;
                tooltipElement.style.cssText = `
                    position: absolute;
                    background: #1e293b;
                    color: white;
                    padding: 10px;
                    border-radius: 6px;
                    font-size: 0.9em;
                    max-width: 300px;
                    z-index: 1000;
                    pointer-events: none;
                    word-wrap: break-word;
                `;

                document.body.appendChild(tooltipElement);

                const rect = e.target.getBoundingClientRect();
                tooltipElement.style.left = (rect.left + window.scrollX) + 'px';
                tooltipElement.style.top = (rect.top + window.scrollY - tooltipElement.offsetHeight - 10) + 'px';
            });

            tooltip.addEventListener('mouseleave', () => {
                if (tooltipElement) {
                    document.body.removeChild(tooltipElement);
                    tooltipElement = null;
                }
            });
        });

        // Enhanced tooltip implementation for preset buttons
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(button => {
            let tooltipElement = null;

            button.addEventListener('mouseenter', (e) => {
                // Don't show tooltip if clicking on info icon
                if (e.target.classList.contains('preset-tooltip-trigger')) return;

                const text = button.getAttribute('data-tooltip');
                if (!text) return;

                tooltipElement = document.createElement('div');
                tooltipElement.className = 'preset-hover-tooltip';
                tooltipElement.innerHTML = text;
                tooltipElement.style.cssText = `
                    position: absolute;
                    background: #2d3748;
                    color: white;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 11px;
                    max-width: 350px;
                    z-index: 1000;
                    pointer-events: none;
                    word-wrap: break-word;
                    line-height: 1.4;
                    border: 1px solid #4a5568;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;

                document.body.appendChild(tooltipElement);

                const rect = button.getBoundingClientRect();
                tooltipElement.style.left = (rect.left + window.scrollX) + 'px';
                tooltipElement.style.top = (rect.top + window.scrollY - tooltipElement.offsetHeight - 12) + 'px';

                // Adjust if tooltip goes off screen
                if (tooltipElement.getBoundingClientRect().left < 0) {
                    tooltipElement.style.left = '10px';
                }
                if (tooltipElement.getBoundingClientRect().right > window.innerWidth) {
                    tooltipElement.style.left = (window.innerWidth - tooltipElement.offsetWidth - 10) + 'px';
                }
            });

            button.addEventListener('mouseleave', () => {
                if (tooltipElement) {
                    document.body.removeChild(tooltipElement);
                    tooltipElement = null;
                }
            });
        });
    }

    initializeFormulaModal() {
        const infoBtn = document.getElementById('formula-info-btn');
        const infoBox = document.getElementById('formula-info-box');

        if (infoBtn && infoBox) {
            infoBtn.addEventListener('click', () => {
                if (infoBox.style.display === 'none') {
                    this.updateInfoBox();
                    infoBox.style.display = 'block';
                } else {
                    infoBox.style.display = 'none';
                }
            });
        }
    }

    updateInfoBox() {
        const params = this.getCurrentParameters();

        document.getElementById('info-mu').textContent = params.mu;
        document.getElementById('info-nu').textContent = params.nu;
        document.getElementById('info-h').textContent = params.H;
    }

    switchTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`.tab-button[data-tab="${tabName}"]`).classList.add('active');

        // Update tab content
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        document.getElementById(`${tabName}-tab`).classList.add('active');
    }

    updateParameterDisplays() {
        document.getElementById('mu-value').textContent = document.getElementById('mu-slider').value;
        document.getElementById('nu-value').textContent = document.getElementById('nu-slider').value;
        document.getElementById('H-value').textContent = document.getElementById('H-slider').value;
        document.getElementById('volatility-value').textContent = document.getElementById('volatility-slider').value;
        document.getElementById('tx-per-block-value').textContent = document.getElementById('tx-per-block-slider').value;
        document.getElementById('duration-value').textContent = parseFloat(document.getElementById('duration-slider').value).toFixed(1);

        // Update minimum deficit rate display
        const exponentValue = parseFloat(document.getElementById('min-deficit-rate-slider').value);
        const actualValue = Math.pow(10, exponentValue);
        document.getElementById('min-deficit-rate-value').textContent = actualValue.toExponential(3);
    }

    toggleMinDeficitRateVisibility(show) {
        const deficitRateGroup = document.getElementById('min-deficit-rate-group');
        deficitRateGroup.style.display = show ? 'block' : 'none';
    }

    getCurrentParameters() {
        // Determine active tab
        const activeTab = document.querySelector('.tab-button.active').dataset.tab;
        const isSimulated = activeTab === 'simulated';
        const historicalPeriod = isSimulated ? null : document.querySelector('input[name="historical-period"]:checked').value;

        // Calculate minimum deficit rate from the exponential slider
        const minDeficitRateExponent = parseFloat(document.getElementById('min-deficit-rate-slider').value);
        const minDeficitRateValue = Math.pow(10, minDeficitRateExponent);

        const params = {
            mu: parseFloat(document.getElementById('mu-slider').value),
            nu: parseFloat(document.getElementById('nu-slider').value),
            H: parseInt(document.getElementById('H-slider').value),
            l1Volatility: parseFloat(document.getElementById('volatility-slider').value),
            l1Source: isSimulated ? 'simulated' : 'historical',
            historicalPeriod: historicalPeriod,
            seed: parseInt(document.getElementById('seed-input').value),
            vaultInit: document.getElementById('vault-init').value,
            txsPerBatch: parseInt(document.getElementById('tx-per-block-slider').value),
            spikeDelay: parseInt(document.getElementById('spike-delay-slider').value),
            spikeHeight: parseFloat(document.getElementById('spike-height-slider').value),
            guaranteedRecovery: document.getElementById('guaranteed-recovery').checked,
            minDeficitRate: minDeficitRateValue,
            durationHours: parseFloat(document.getElementById('duration-slider').value),
            targetBalance: 100,
            feeElasticity: 0.2,
            minFee: 1e-8
        };

        console.log(`App parameters:`, params);
        return params;
    }

    loadPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) return;

        // Update sliders
        document.getElementById('mu-slider').value = preset.mu;
        document.getElementById('nu-slider').value = preset.nu;
        document.getElementById('H-slider').value = preset.H;

        // Update displays
        this.updateParameterDisplays();

        // Mark as modified since preset changed parameters
        this.markParametersModified();

        console.log(`Loaded preset: ${presetName}`, preset);
    }

    setActivePreset(buttonElement) {
        // Clear all active states
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        // Set active state
        buttonElement.classList.add('active');
    }

    clearActivePreset() {
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.classList.remove('active');
        });
    }

    markParametersModified() {
        // Auto-run simulation after delay
        if (this.autoRunEnabled && !this.isRunning) {
            clearTimeout(this.autoRunTimeout);
            this.autoRunTimeout = setTimeout(() => {
                if (!this.isRunning) {
                    this.runSimulation();
                }
            }, this.autoRunDelay);
        }
    }


    async runSimulation() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.showLoading(true);

        try {
            const params = this.getCurrentParameters();
            console.log('Running simulation with parameters:', params);

            // Create simulator
            const simulator = new TaikoFeeSimulator(params);

            // Calculate steps from duration (1800 steps per hour for 2-second Taiko blocks)
            const simulationSteps = Math.round(params.durationHours * 1800);

            // Convert percentage-based spike delay to actual steps
            params.spikeDelaySteps = Math.round((params.spikeDelay / 100) * simulationSteps);

            // Run simulation (use setTimeout to make it non-blocking)
            await new Promise(resolve => setTimeout(resolve, 100));
            const simulationData = await simulator.runSimulation(simulationSteps);

            console.log('Simulation completed, data points:', simulationData.length);

            // Calculate metrics
            const metricsCalculator = new MetricsCalculator(params.targetBalance, simulator.gasPerTx);
            const metrics = metricsCalculator.calculateMetrics(simulationData);

            console.log('Calculated metrics:', metrics);

            // Store data
            this.currentSimulationData = simulationData;

            // Update UI
            this.updateMetricsDisplay(metrics);
            this.updateCharts(simulationData, simulator.gasPerTx);

        } catch (error) {
            console.error('Simulation error:', error);
            alert('Error running simulation: ' + error.message);
        } finally {
            this.isRunning = false;
            this.showLoading(false);
        }
    }

    updateMetricsDisplay(metrics) {
        const evaluations = this.chartManager.evaluateMetrics(metrics);

        // Update each metric card
        this.chartManager.updateMetricCard('avg-fee-card', metrics.avgFee, evaluations.avgFee);
        this.chartManager.updateMetricCard('fee-cv-card', metrics.feeCV, evaluations.feeCV);
        this.chartManager.updateMetricCard('underfunded-card', metrics.timeUnderfundedPct, evaluations.timeUnderfunded);
        this.chartManager.updateMetricCard('tracking-card', metrics.l1TrackingError, evaluations.l1Tracking);
    }

    updateCharts(simulationData, gasPerTx) {
        const params = this.getCurrentParameters();

        // Debug: Log gasPerTx value for data quality tracking
        console.log(`üìä Chart update: gasPerTx = ${gasPerTx} (type: ${typeof gasPerTx})`);
        if (!gasPerTx || gasPerTx <= 0) {
            console.error(`üö® CRITICAL: Invalid gasPerTx passed to charts: ${gasPerTx}`);
        } else if (gasPerTx < 1000 || gasPerTx > 50000) {
            console.warn(`‚ö†Ô∏è Unexpected gasPerTx value: ${gasPerTx} (expected ~20,000)`);
        } else {
            console.log(`‚úÖ gasPerTx value looks reasonable: ${gasPerTx}`);
        }

        // Create/update all charts
        this.chartManager.createFeeChart('fee-chart', simulationData, gasPerTx);
        this.chartManager.createVaultChart('vault-chart', simulationData, params.targetBalance);
        this.chartManager.createL1Chart('l1-chart', simulationData);
        this.chartManager.createCorrelationChart('correlation-chart', simulationData, gasPerTx);
        this.chartManager.createL1EstimationChart('l1-estimation-chart', simulationData, gasPerTx);
    }

    showLoading(show) {
        const overlay = document.getElementById('loading-overlay');

        if (show) {
            overlay.style.display = 'flex';
        } else {
            overlay.style.display = 'none';
        }
    }

    // Export functionality
    exportResults() {
        if (!this.currentSimulationData) {
            alert('No simulation data to export. Please run a simulation first.');
            return;
        }

        const params = this.getCurrentParameters();
        const exportData = {
            timestamp: new Date().toISOString(),
            parameters: params,
            simulationData: this.currentSimulationData
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

        const exportFileDefaultName = 'taiko-fee-simulation.json';

        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }

    // Preset Tooltip Methods
    initializePresetTooltip() {
        const modal = document.getElementById('preset-tooltip-modal');
        const closeBtn = document.querySelector('.preset-tooltip-close');

        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
        }

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.style.display === 'block') {
                modal.style.display = 'none';
            }
        });
    }

    showPresetTooltip(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) return;

        const modal = document.getElementById('preset-tooltip-modal');
        const title = document.getElementById('preset-tooltip-title');
        const details = document.getElementById('preset-tooltip-details');

        title.textContent = `${preset.description}`;
        details.innerHTML = this.generatePresetTooltipContent(presetName, preset);

        modal.style.display = 'block';

        // Re-render MathJax for the new LaTeX content
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([modal]).catch((err) => console.log('MathJax error:', err));
        }
    }

    generatePresetTooltipContent(presetName, preset) {
        const researchData = this.getPresetResearchData(presetName);

        return `
            <div class="preset-detail-section">
                <h5>üîß Parameter Configuration</h5>
                <div class="preset-parameters">
                    <div class="preset-param">Œº = ${preset.mu}</div>
                    <div class="preset-param">ŒΩ = ${preset.nu}</div>
                    <div class="preset-param">H = ${preset.H}</div>
                </div>
            </div>

            <div class="preset-detail-section">
                <h5>üìê Mathematical Formula</h5>
                <div class="preset-formula">
                    $$F_E(t) = \\max\\left(${preset.mu} \\times C_{L1}(t) + ${preset.nu} \\times \\frac{D(t)}{${preset.H}}, F_{\\text{min}}\\right)$$
                </div>
                <p style="font-size: 11px; color: #666; margin: 8px 0 0 0;">
                    ${this.getFormulaExplanation(preset)}
                </p>
            </div>

            <div class="preset-detail-section">
                <h5>üéØ Objective & Constraints</h5>
                <div class="preset-optimization">
                    <div class="preset-objective">
                        <h6>Primary Objective:</h6>
                        <p>${preset.objective || 'Not specified'}</p>
                    </div>
                    <div class="preset-constraints">
                        <h6>Constraints:</h6>
                        <p>${preset.constraints || 'Not specified'}</p>
                    </div>
                    <div class="preset-risk">
                        <h6>Risk Profile:</h6>
                        <p>${preset.riskProfile || 'Not specified'}</p>
                    </div>
                </div>
            </div>

            <div class="preset-detail-section">
                <h5>‚öñÔ∏è Trade-offs Analysis</h5>
                <div class="preset-tradeoffs">
                    <p>${preset.tradeoffs || 'Not specified'}</p>
                    <h6>Research Validation:</h6>
                    <ul class="preset-optimization-list">
                        <li>Comprehensive simulations across crisis scenarios</li>
                        <li>Multi-objective optimization: minimize fees + maximize vault stability</li>
                        <li>Historical data: May 2022 crash, July 2022 spike, May 2023 PEPE, Recent low fees</li>
                        <li>Pareto frontier analysis for optimal trade-offs</li>
                    </ul>
                </div>
            </div>

            <div class="preset-detail-section">
                <h5>üî¨ Research Methodology & Status</h5>
                <div class="preset-performance">
                    <div class="preset-methodology">
                        <h6>Research Methodology:</h6>
                        <p>${researchData.methodology}</p>
                    </div>
                    <div class="preset-data-source">
                        <h6>Data Sources:</h6>
                        <p>${researchData.dataSource}</p>
                    </div>
                    <div class="preset-research-status">
                        <h6>Current Status:</h6>
                        <p>${researchData.researchStatus}</p>
                    </div>
                    <div class="preset-metric">
                        <span>Expected Time Underfunded:</span>
                        <span class="preset-metric-value">${researchData.timeUnderfunded}</span>
                    </div>
                </div>
            </div>

            <div class="preset-detail-section">
                <h5>üèóÔ∏è Use Case & Trade-offs</h5>
                <div class="preset-use-case">
                    <strong>Best Used For:</strong> ${preset.useCase}
                </div>
                <div class="preset-use-case">
                    <strong>Trade-off Analysis:</strong> ${researchData.tradeoffs}
                </div>
            </div>
        `;
    }

    getFormulaExplanation(preset) {
        if (preset.mu === 0.0) {
            return `Pure deficit correction: fees only depend on vault deficit (${preset.nu} √ó D(t)/${preset.H}), completely ignoring L1 costs. This minimizes fees while maintaining vault stability.`;
        } else if (preset.nu === 0.0) {
            return `Pure L1 tracking: fees only depend on L1 costs (${preset.mu} √ó C_L1(t)), ignoring vault deficit. This provides predictable cost reflection but no vault management.`;
        } else {
            return `Hybrid approach: fees balance L1 cost reflection (${preset.mu} √ó C_L1(t)) with vault deficit correction (${preset.nu} √ó D(t)/${preset.H}). Higher Œº = more L1 sensitivity, higher ŒΩ = faster deficit correction.`;
        }
    }

    getPresetResearchData(presetName) {
        const researchData = {
            'optimal': {
                avgFee: 'N/A - Research Pending',
                timeUnderfunded: 'N/A - Research Pending',
                feeVolatility: 'N/A - Research Pending',
                l1TrackingError: 'N/A - Research Pending',
                methodology: '360 simulations across 4 historical crisis scenarios with multi-objective Pareto optimization',
                researchStatus: 'Configuration designed for Œº=0.0, ŒΩ=0.3, H=288 based on deficit correction optimization. Full performance validation pending.',
                dataSource: 'Historical Ethereum data: July 2022 spike, May 2022 UST crash, May 2023 PEPE crisis, Recent low fees',
                tradeoffs: 'Research-based deficit correction strategy. Ignores L1 costs (Œº=0.0) for minimal fees while using moderate deficit correction (ŒΩ=0.3) for stability.'
            },
            'balanced': {
                avgFee: 'N/A - Research Pending',
                timeUnderfunded: 'N/A - Research Pending',
                feeVolatility: 'N/A - Research Pending',
                l1TrackingError: 'N/A - Research Pending',
                methodology: '360 simulations with comprehensive parameter sweep and crisis scenario testing',
                researchStatus: 'Configuration designed for Œº=0.0, ŒΩ=0.1, H=576 for conservative deficit correction. Performance metrics under validation.',
                dataSource: 'Multi-regime backtesting on real Ethereum L1 basefee data spanning normal and crisis periods',
                tradeoffs: 'Very conservative deficit correction approach. Extended horizon (H=576) provides stability but slower response to deficits compared to optimal config.'
            },
            'crisis-resilient': {
                avgFee: 'N/A - Research Pending',
                timeUnderfunded: 'Expected < 5%',
                feeVolatility: 'Expected Low',
                l1TrackingError: 'N/A (Pure deficit approach)',
                methodology: 'Crisis stress testing across extreme volatility scenarios with aggressive deficit correction',
                researchStatus: 'Configuration Œº=0.0, ŒΩ=0.9, H=144 designed for maximum vault recovery speed during crises.',
                dataSource: 'Historical crisis scenarios: ETH fee spikes (8-533 gwei), meme coin congestion, UST/Luna crash',
                tradeoffs: 'Aggressive deficit correction (ŒΩ=0.9) prioritizes vault stability over fee minimization. Faster response than other configs but potentially higher fees during recovery periods.'
            }
        };

        return researchData[presetName] || researchData['optimal'];
    }
}

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ Taiko Fee Explorer initializing...');

    // Check if required dependencies are loaded
    console.log('üì¶ Checking dependencies...');
    console.log('- Chart.js:', typeof Chart !== 'undefined');
    console.log('- THREE.js:', typeof THREE !== 'undefined');
    console.log('- TaikoFeeSimulator:', typeof TaikoFeeSimulator !== 'undefined');
    console.log('- OptimizationResearchController:', typeof OptimizationResearchController !== 'undefined');
    console.log('- ParetoVisualizer:', typeof ParetoVisualizer !== 'undefined');

    if (typeof Chart === 'undefined') {
        console.error('‚ùå Chart.js not loaded');
        return;
    }

    if (typeof TaikoFeeSimulator === 'undefined') {
        console.error('‚ùå Simulator not loaded');
        return;
    }

    // Initialize the application
    window.taikoExplorer = new TaikoFeeExplorer();

    // Initialize the optimization research interface
    if (typeof OptimizationResearchController !== 'undefined') {
        window.optimizationResearch = new OptimizationResearchController();
        console.log('Optimization Research Controller initialized successfully');
    } else {
        console.error('OptimizationResearchController not loaded');
    }

    console.log('Taiko Fee Explorer initialized successfully');

    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + Enter to run simulation
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            window.taikoExplorer.runSimulation();
        }

        // Ctrl/Cmd + E to export results
        if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
            e.preventDefault();
            window.taikoExplorer.exportResults();
        }
    });

    // Show keyboard shortcuts in console
    console.log('Keyboard shortcuts:');
    console.log('Ctrl/Cmd + Enter: Run simulation');
    console.log('Ctrl/Cmd + E: Export results');
});
